import 'dart:math';

class DartBook {
  String title;
  String description;
  //String programImage;

  DartBook({
    required this.title,
    required this.description,
    //required this.programImage,
  });
}

List<DartBook> chaptarList = [
  DartBook(
      title: 'ডার্ট প্রোগ্রামিং ভাষা পরিচিতি',
      //programImage: 'ডার্ট প্রোগ্রামিং ভাষা পরিচিতি',
      description:
<<<<<<< Updated upstream
          '''ডার্ট একটি সহজ এবং পাওয়ারফুল প্রোগ্রামিং ভাষা যা গুগল দ্বারা তৈরি হয়েছে, এবং এটি ওয়েব ডেভেলপমেন্ট এবং মোবাইল ডেভেলপমেন্টে ব্যবহৃত হয়। এটি একটি ওপেন সোর্স প্রোজেক্ট এবং এর দ্বারা ওয়েব এবং মোবাইল অ্যাপ্লিকেশন তৈরি করা যায়।
          ডার্ট সিনট্যাক্স উদাহরণ:
          void main() { 
            print('Hello, World!'); 

            // ভেরিয়েবল ডিক্লেয়ারেশন এবং মান প্রদান
            String name = 'John'; 
            int age = 30; 
            double salary = 50000.50; 
            bool isEmployed = true; 

            // কন্ডিশনাল স্টেটমেন্ট 
            if (age > 18) {
              print('$name is an adult.'); 
            } 
            else {
              print('$name is a minor.');
            } 

            // লুপ 
            for (int i = 0; i < 5; i++) { 
              print('Count: $i'); 
            } 

            // ফাংশন ডিফাইনিশন 
            void greet() { 
              print('Hello, $name!'); 
            } 
            // ফাংশন কল 
            greet(); 
          } 
        '''),
=======
          '''Lorem Ipsum is পরিচিতি dummy text of the printing and typesetting industry.
          Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.'''),
>>>>>>> Stashed changes
  DartBook(
      title: 'কীওয়ার্ড (Keywords)',
      description:
          '''কীওয়ার্ড (Keywords) হলো সাধারণভাবে প্রোগ্রামিং ভাষাতে নিয়মিতভাবে ব্যবহৃত শব্দগুলি যা প্রোগ্রামের সম্প্রদায় এবং স্ট্রাকচার নির্ধারণ করে। এটির মাধ্যমে কোড রিডেবল এবং সম্বোধনীয় হয়। এখানে কিছু ডার্ট কীওয়ার্ড দেওয়া হলো:

          var: একটি ভেরিয়েবল ডিক্লেয়ার করার জন্য ব্যবহৃত হয়। এটি প্রথমে ভেরিয়েবলের ডেটা টাইপ নির্ধারণ করে না।
          final: একটি প্রায় স্থায়ী ভেরিয়েবল ডিক্লেয়ার করার জন্য ব্যবহৃত হয়। এটি একবার মান প্রদান করার পর পরিবর্তন করা যায় না।
          const: একটি স্থায়ী ভেরিয়েবল ডিক্লেয়ার করার জন্য ব্যবহৃত হয়, যেটি কোড কম্পাইলেশন সময়ে নির্ধারিত হয়।
          if: একটি শর্ত চেক করার জন্য ব্যবহৃত হয়, এবং শর্ত সত্য হলে নির্দিষ্ট ব্লক কোড সম্পাদন করে।
          else: একটি 'if' ব্লকের পর 'if' ব্লকের শর্ত মিথ্যা হলে সম্পাদন কাজ করার জন্য ব্যবহৃত হয়।
          for: একটি লুপ স্টেটমেন্ট, যা একই কাজ নির্দিষ্ট সংখ্যক সময়ে বারবার সম্পাদন করে।
          while: একটি লুপ স্টেটমেন্ট, যা কোন সময়ে দেওয়া শর্ত সত্য হলে সম্পাদন কাজ সম্পাদন করে।
          return: একটি ফাংশন থেকে মান প্রেরণ করার জন্য ব্যবহৃত হয়।
          void: একটি ফাংশন যেটি কোন মান প্রেরণ করে না।
          class: একটি ক্লাস ডিফাইন করার জন্য ব্যবহৃত হয়, যা অবজেক্ট তৈরি করার জন্য ব্যবহার করা যায়।
          extends: একটি ক্লাস এর বৈশিষ্ট্য এবং মেথডগুলি একটি অন্য ক্লাসে বেশি করে ব্যবহার করার জন্য ব্যবহৃত হয়।
          new: অবজেক্ট তৈরির সময় ব্যবহৃত হয়, উদাহরণস্বরূপ: var obj = new ClassName();
          import: অন্য মডিউল (ফাইল) থেকে কোড ইমপোর্ট করার জন্য ব্যবহৃত হয়।
          library: একটি মডিউল ফাইল ডিফাইন করার জন্য ব্যবহৃত হয়, যা একটি লাইব্রেরি সম্পর্কে নির্দিষ্ট করে।
          try: একটি কোড ব্লকের ভেতর একটি এক্সেপশন থ্রো হলে যে কাজ করবে তা নির্দিষ্ট করার জন্য ব্যবহৃত হয়।
          catch: একটি এক্সেপশন ক্যাচ করার জন্য ব্যবহৃত হয়, এবং সে এক্সেপশন সম্পর্কে তথ্য প্রদান করে।
          throw: একটি এক্সেপশন থ্রো করার জন্য ব্যবহৃত হয়।
          finally: একটি ট্রাই-ক্যাচ ব্লকের ভেতর সম্পাদন কাজ করার আগে সম্পাদন কাজ সম্পাদন করার জন্য ব্যবহৃত হয়।
          this: একটি অবজেক্টের বৈশিষ্ট্য বা মেথডের মধ্যে সাম্প্রদায়িক প্রসারণে ব্যবহৃত হয়, সম্পাদন কাজের জন্য।
          super: একটি সাম্প্রদায়িক ক্লাসের বৈশিষ্ট্য বা মেথড ব্যবহার করার জন্য ব্যবহৃত হয়, সাবক্লাসের সম্পাদন কাজের জন্য
          async: এটি একটি এসিঙ্ক্রোনাস ফাংশন ডিক্লেয়ার করতে ব্যবহৃত হয়, যা ব্যাকগ্রাউন্ডে কোড সম্পাদন করতে সাহায্য করে।
          await: এটি একটি এসিঙ্ক্রোনাস ফাংশনের মধ্যে ব্যবহৃত হয় এবং এটি একটি প্রমিস (Promise) এর সম্পর্কে বিশেষ মুহূর্তের অপেক্ষা করে।
          async*: এটি একটি সাধারণ এসিঙ্ক্রোনাস ইটারেটর ডিক্লেয়ার করতে ব্যবহৃত হয়, যা একটি কাস্টম ইটারেটর তৈরি করে এবং ডাটা সোর্স থেকে মান প্রয়োগ করে।
          এই কীওয়ার্ড গুলি ডার্ট প্রোগ্রামিং এ ব্যবহৃত হয় এবং প্রোগ্রামিং ভাষার নির্দিষ্ট কাজের নির্দেশনা দেয়। আপনি এই কীওয়ার্ড গুলি ব্যবহার করে ডার্ট প্রোগ্রাম লেখার সময় তাদের কাজ সম্পর্কে সঠিক বোঝতে সাহায্য পেতে পারেন।
        '''),
  DartBook(
      title: 'ভেরিয়েবল (Variable)',
      description:
          '''ভেরিয়েবল (Variable) হলো একটি ডেটা স্টোর করার জন্য ব্যবহৃত একটি নাম, যা প্রোগ্রামের মধ্যে ডেটা সংরক্ষণ করে। ডার্ট ভাষায়, ভেরিয়েবল দ্বারা একটি মূল্য সংরক্ষণ করা হয় এবং সেই মূল্যটি প্রোগ্রামের যেখানেই ব্যবহৃত হতে পারে।

          ভেরিয়েবলের ডিক্লেয়ারেশন (Variable Declaration):
          ডার্ট ভাষায় একটি ভেরিয়েবল ডিক্লেয়ার করতে, প্রথমে ভেরিয়েবলের ডেটা টাইপ নির্ধারণ করে তারপর একটি নাম নির্ধারণ করতে হয়, এবং আপনি সম্পর্কিত মূল্য সেট করতে পারেন (অথবা সেট না করতে পারেন)।
          উদাহরণ:
          int age = 25; // একটি int টাইপ ভেরিয়েবল ডিক্লেয়ার এবং মূল্য সেট করা হয় 
          String name; // একটি String টাইপ ভেরিয়েবল ডিক্লেয়ার করা হয়, মূল্য সেট না করা হয় 
          double salary = 50000.0; // একটি double টাইপ ভেরিয়েবল ডিক্লেয়ার এবং মূল্য সেট করা হয় 

          ভেরিয়েবলের আপডেট (Variable Update):
          ভেরিয়েবলের মান আপডেট করতে আপনি সম্পর্কিত ভেরিয়েবলে নতুন মান অ্যাসাইন করতে পারেন।
          উদাহরণ:
          int count = 10; // ভেরিয়েবল একটি মান সেট করা হয় 
          count = 15; // মান আপডেট করা হয় 

          ডাইনামিক টাইপ ভেরিয়েবল (Dynamic Typing):
          ডার্ট ভাষাতে ভেরিয়েবলের ডাইনামিক টাইপ পর্যায়ক্রমে ভেরিয়েবলে যে কোন ডেটা টাইপ অ্যাসাইন করা যেতে পারে, এবং এটি রানটাইমে মান পরিবর্তন করা যেতে পারে।
          উদাহরণ:
          var value = 10; // ডাইনামিক টাইপ ভেরিয়েবল, এখানে int মান অ্যাসাইন করা হয় 
          value = "Hello"; // ডাইনামিক টাইপ ভেরিয়েবল, এখানে String মান অ্যাসাইন করা হয় 

          ভেরিয়েবলের নাম নির্ধারণ (Variable Naming):
          ভেরিয়েবলের নাম কেস-সেনসিটিভ (case-sensitive) এবং স্পেস থাকতে পারে না।
          ভেরিয়েবলের নাম একটি বৈধ Dart আইডেন্টিফায়ার (identifier) হতে হবে, যা অক্ষর, সংখ্যা, এবং আন্ডারস্কোর (_) অক্ষরের সমন্বয়ে গঠিত হতে হবে।
          ভেরিয়েবলের নাম সংখ্যা দিয়ে শুরু করা যায় না।
          স্ট্রিংের ভেরিয়েবলের নাম বলা উচিত এমন নাম যা ভেরিয়েবলের উদ্দেশ্য নির্ধারণ করে।
          সারসংক্ষেপে, ডার্ট ভাষায় ভেরিয়েবল হলো ডেটা স্টোর করার উদ্দেশ্যে ব্যবহৃত একটি নাম, যা প্রোগ্রামের মধ্যে মূল্য সংরক্ষণ করে এবং প্রোগ্রামের যেখানেই ব্যবহার করা যেতে পারে।
        '''),
  DartBook(
      title: 'অপারেটর (Operators)',
      description:
          '''অপারেটর (Operators) হলো বিভিন্ন মান বা এক্সপ্রেশনের মধ্যে কার্যকরী করে এবং মানগুলি প্রকাশ করার জন্য ব্যবহৃত সুচনা সিম্বল বা কীওয়ার্ড। অপারেটরগুলি মান মনিপুলেশন, গণনা, সময়োচিত ক্রিয়া, তুলনা, যোগফল ইত্যাদি করার জন্য ব্যবহৃত হয়।
            ডার্টে প্রধানভাবে নিম্নলিখিত ধরণের অপারেটর ব্যবহৃত হয়:
            অ্যারিথমেটিক অপারেটর (Arithmetic Operators): গণনা করার জন্য ব্যবহৃত হয়।
            + : যোগ অপারেটর, দুটি মান যোগ করে।
            - : বিয়োগ অপারেটর, একটি মান থেকে অন্যটি বিয়োগ করে।
            * : গুণন অপারেটর, দুটি মান গুণ করে।
            / : ভাগ অপারেটর, একটি মান থেকে অন্যটি ভাগ করে।
            % : ভাগশেষ অপারেটর, একটি মান থেকে অন্যটি ভাগ করলে যে ভাগশেষ পাওয়া যায় তা দেখায়।
            ~/ : ফ্লোর ভাগ অপারেটর, একটি মান থেকে অন্যটি ভাগ করে এবং ফ্লোর ফাংশন দ্বারা নিকটতম পূর্ণসংখ্যা দেখায়।
            উদাহরণ:
            int a = 10; 
            int b = 5; 
            print(a + b); // যোগ 
            print(a - b); // বিয়োগ 
            print(a * b); // গুণ 
            print(a / b); // ভাগ 
            print(a % b); // ভাগশেষ 
            print(a ~/ b); // ফ্লোর ভাগ 

            বন্ধনী অপারেটর (Assignment Operators): একটি মানকে একটি ভেরিয়েবলে অ্যাসাইন করার জন্য ব্যবহৃত হয়।
            = : একটি মানকে ভেরিয়েবলে অ্যাসাইন করার জন্য ব্যবহৃত হয়।
            += : ভেরিয়েবলের মানে অন্য একটি মান যোগ করে এবং ফলাফল ভেরিয়েবলে সংরক্ষণ করে।
            -= : ভেরিয়েবলের মান থেকে অন্য একটি মান বিয়োগ করে এবং ফলাফল ভেরিয়েবলে সংরক্ষণ করে।
            *= : ভেরিয়েবলের মানে অন্য একটি মান গুণ করে এবং ফলাফল ভেরিয়েবলে সংরক্ষণ করে।
            /= : ভেরিয়েবলের মান থেকে অন্য একটি মান ভাগ করে এবং ফলাফল ভেরিয়েবলে সংরক্ষণ করে।
            উদাহরণ:
            int x = 10; 
            x += 5; 
            // x = x + 5 x -= 3; 
            // x = x - 3 x *= 2; 
            // x = x * 2 x /= 4; 
            // x = x / 4 

            সম্পর্কিত অপারেটর (Relational Operators): দুটি মানের সম্পর্ক নির্ধারণ করার জন্য ব্যবহৃত হয়, এবং এই অপারেটরগুলি সত্য (true) বা মিথ্যা (false) মূল্য প্রকাশ করে।
            == : দুটি মান সমান হলে সত্য প্রকাশ করে।
            != : দুটি মান বেরোধ হলে সত্য প্রকাশ করে।
            > : প্রথম মান দ্বিতীয় মানের চেয়ে বড় হলে সত্য প্রকাশ করে।
            < : প্রথম মান দ্বিতীয় মানের চেয়ে ছোট হলে সত্য প্রকাশ করে।
            >= : প্রথম মান দ্বিতীয় মানের চেয়ে বড় বা সমান হলে সত্য প্রকাশ করে।
            <= : প্রথম মান দ্বিতীয় মানের চেয়ে ছোট বা সমান হলে সত্য প্রকাশ করে।
            উদাহরণ:
            int p = 10; 
            int q = 5; 
            bool result = (p == q); // প্রথম এবং দ্বিতীয় মান সমান না, তাহলে result মানটি মিথ্যা 

            লজিক্যাল অপারেটর (Logical Operators): বুলিয়ান মানের সম্পর্ক নির্ধারণ করার জন্য ব্যবহৃত হয়।
            && : লজিক্যাল এন্ড (AND) অপারেটর, যদি দুটি শর্ত সত্য হয় তাহলে সত্য প্রকাশ করে।
            || : লজিক্যাল অর (OR) অপারেটর, যদি দুটি শর্ত যেকোন একটি সত্য হয় তাহলে সত্য প্রকাশ করে।
            ! : লজিক্যাল নট (NOT) অপারেটর, যদি মন্য শর্ত মিথ্যা হয় তাহলে সত্য প্রকাশ করে, এবং যদি শর্ত সত্য হয় তাহলে মিথ্যা প্রকাশ করে।
            উদাহরণ:
            bool isTrue = true; 
            bool isFalse = false; 
            bool result1 = isTrue && isFalse; // সত্য AND মিথ্যা, তাহলে result1 মানটি মিথ্যা 
            bool result2 = isTrue || isFalse; // সত্য OR মিথ্যা, তাহলে result2 মানটি সত্য 
            bool result3 = !isTrue; // নট সত্য, তাহলে result3 মানটি মিথ্যা 

            পোস্টফিক্স এবং প্রিফিক্স ইনক্রিমেন্ট/ডিক্রিমেন্ট অপারেটর (Postfix and Prefix Increment/Decrement Operators): এই অপারেটরগুলি ভেরিয়েবলের মানকে 1 বা একটি মৌলিক সংখ্যা বাড়ানো অথবা কমানোর জন্য ব্যবহৃত হয়।
            ++ : ইনক্রিমেন্ট অপারেটর, ভেরিয়েবলের মানকে 1 বাড়াতে ব্যবহৃত হয়।
            -- : ডিক্রিমেন্ট অপারেটর, ভেরিয়েবলের মানকে 1 কমিয়ে দেয়।
            উদাহরণ:
            int count = 5; 
            count++; // ইনক্রিমেন্ট, এখন count মান 6 
            count--; // ডিক্রিমেন্ট, এখন count মান 5 

            কন্ডিশনাল অপারেটর (Conditional Operator): এটি একটি শর্ত অনুযায়ী মান নির্ধারণ করে।
            condition ? expr1 : expr2 : এটি একটি শর্ত যাচাই করে, যদি শর্ত সত্য হয় তাহলে expr1 মানটি প্রকাশ করে, অন্যথায় expr2 মানটি প্রকাশ করে।
            উদাহরণ:
            int x = 10; 
            int y = 5; 
            int result = x > y ? x : y; // যদি x > y সত্য হয় তাহলে x প্রকাশ করে, অন্যথায় y প্রকাশ করে।

            এই অপারেটরগুলি ডার্ট ভাষার মূল অপারেটরগুলি এবং প্রোগ্রামে মানগুলির সম্পর্ক নির্ধারণ, গণনা এবং যোগফলের জন্য ব্যবহৃত হয়। এই অপারেটরগুলি ডার্ট প্রোগ্রামে ব্যবহার করে বিভিন্ন ধরণের কাজ সম্পাদনা করতে সাহায্য করে।
          '''),
  DartBook(
      title: 'ডেটা টাইপ (Data Types)',
      description:
          '''ডেটা টাইপ (Data Types) হলো ভ্যারিয়েবলের মান এবং ধরণ নির্ধারণ করার জন্য ব্যবহৃত স্পেসিফিক কোড স্যাম্পল। ডেটা টাইপ স্পেসিফিক অবজেক্ট বা মান টাইপ নির্দিষ্ট করে যা ভ্যারিয়েবলে সংরক্ষণ করা যায়।
            ডার্টে প্রধানভাবে নিম্নলিখিত ডেটা টাইপগুলি আছে:
            int: এটি পূর্ণসংখ্যা প্রকাশ করার জন্য ব্যবহৃত হয়।।
            double: এটি দশমিক সংখ্যা টাইপ, এবং দশমিক সংখ্যাগুলি প্রকাশ করার জন্য ব্যবহৃত হয়।
            num: এটি সংখ্যাগুলির মধ্যে কোন কোন সংখ্যা টাইপ হতে পারে, অর্থাৎ পূর্ণসংখ্যা বা দশমিক সংখ্যা টাইপ হতে পারে।
            String: এটি টেক্সট স্ট্রিং টাইপ, যা টেক্সট এবং ক্যারেক্টার সমূহ প্রকাশ করতে ব্যবহৃত হয়।
            bool: এটি বুলিয়ান টাইপ, যা সত্য বা মিথ্যা স্টেটমেন্ট প্রকাশ করতে ব্যবহৃত হয়।
            List: এটি অ্যারে টাইপ, একটি কালেকশন যাতে একাধিক মান থাকতে পারে।
            Map: এটি ম্যাপ টাইপ, একটি কালেকশন যাতে সংকেত মান সম্পর্কিত থাকে এবং একটি কী (key) দ্বারা ম্যাপ হয়।
            Set: এটি সেট টাইপ, একটি অনুবর্ণনাগত কালেকশন যাতে একই মান একবার মাত্র থাকতে পারে।
            dynamic: এটি ডাইনামিক টাইপ, এটি যে কোন ডেটা টাইপ নেওয়া যেতে পারে এবং প্রোগ্রামে রানটাইমে ডেটা টাইপ পরিবর্তন করা যেতে পারে।

            ডেটা টাইপ ডার্ট প্রোগ্রামে মান এবং বৈশিষ্ট্য নির্ধারণ করতে সাহায্য করে এবং প্রোগ্রামের কোড স্যাম্পল তথ্য প্রদান করে।
          '''),
  DartBook(
      title: 'কনস্ট্যান্ট (Constants)',
      description:
          '''কনস্ট্যান্ট (Constants) হলো মানের একটি নাম যা প্রোগ্রামে পরিবর্তন করা যায় না, অর্থাৎ একবার মান সেট করা হলে পরবর্তীতে মান পরিবর্তন করা যায় না। কনস্ট্যান্ট সাধারণভাবে স্থির (immutable) হয় এবং একবার মান সেট করার পরে পরিবর্তন করা যায় না। এটি প্রোগ্রামের মধ্যে নির্দিষ্ট মানগুলির জন্য ব্যবহৃত হয় যাদের মান পরিবর্তন করা যায় না, এবং সাধারণভাবে প্রোগ্রামের বিভিন্ন অংশে ব্যবহৃত হয়।
            কনস্ট্যান্ট তৈরি করতে ডার্ট ভাষায় const কিওয়ার্ড ব্যবহার করা হয়।
            এটির কিছু উদাহরণ:
            const int age = 25; // একটি মূল্য নির্ধারণ করা কনস্ট্যান্ট 
            const double pi = 3.1416; // একটি মূল্য নির্ধারণ করা কনস্ট্যান্ট 
            const String appName = "MyApp"; // একটি মূল্য নির্ধারণ করা কনস্ট্যান্ট 

            কনস্ট্যান্ট মান একবার সেট করার পরে পরিবর্তন করা যায় না, তাই নিশ্চিত হতে হবে যে আপনি কনস্ট্যান্ট ডিক্লেয়ার করার সময় মান সঠিক আছে এবং আপনি তা পরবর্তীতে পরিবর্তন করতে চান না।
            কনস্ট্যান্ট সম্বন্ধে আরও একটি বৈশিষ্ট্য হলো, এগুলি মানগুলির প্রত্যেকটি মূল্য নির্ধারণ করার সময় প্রোগ্রাম একবার এবং শুরুর সময়ই মূল্য নির্ধারণ করে, যার মাধ্যমে এই মূল্যগুলি কাচাও অত্যন্ত দ্রুত এবং অস্তিত্বমুলক হতে পারে। এটি সাধারণ ভেরিয়েবলের সাথে তুলনা করে এটি একটি প্রাচীনিক ডার্ট কোডে সম্বলিত অধিক কাচাও ওই।

            কনস্ট্যান্ট ব্যবহারের কিছু গুরুত্বপূর্ণ বিষয়:
            কনস্ট্যান্ট সম্পর্কিত ডেটা টাইপ স্পেসিফিক হতে হবে, এবং সেই ডেটা টাইপের মান অ্যাসাইন করতে হবে।
            কনস্ট্যান্ট ক্লাস বা অবজেক্ট তৈরি করতে পারে না। মানে, কোন ক্লাস থেকে কনস্ট্যান্ট অবজেক্ট তৈরি করা যায় না।
            কনস্ট্যান্ট ডেটা তাদের মান অ্যাসাইন করার সময়েই সেট করতে হবে, এটি রানটাইমে মান পরিবর্তন করা যায় না।
            কনস্ট্যান্ট সাধারণ ভেরিয়েবলের সাথে গুরুত্বপূর্ণ পার্থক্য হলো যে কনস্ট্যান্ট মূল্যগুলি কোড কম্পাইলেশনের সময়েই ডিফাইন হয় এবং সেই সাথে সম্প্রদান হয়। এটি কোড পারফর্মেন্সে সুধার সাধারণ ভেরিয়েবলের সাথে তুলনা করে।
            এই সাথে, কনস্ট্যান্ট ব্যবহার করা প্রোগ্রামের নিরাপত্তা বা কোড পারফর্মেন্সে সুধার আনতে সাহায্য করে।
            ডার্ট ভাষায়, কনস্ট্যান্ট তৈরি করার জন্য একে const কীওয়ার্ড বা final কীওয়ার্ড ব্যবহার করে।

            const কীওয়ার্ড
            const কীওয়ার্ড ব্যবহার করে আপনি সম্পূর্ণ স্থায়ী এবং পরিবর্তনশীল মান তৈরি করতে পারেন।
            const কীওয়ার্ড দ্বারা তৈরি মানগুলি কোড প্রোসেসিং সময়ে তৈরি হয়, অর্থাৎ রানটাইমে না।
            const মানগুলি কনস্ট্যান্ট এক্সপ্রেশন হতে হবে, অর্থাৎ রানটাইমে নির্ধারণ করা যায়া না।
            উদাহরণ:
            const int x = 10;
            const double pi = 3.1416; 
            const String appName = 'MyApp'; 

            final কীওয়ার্ড
            final কীওয়ার্ড ব্যবহার করে আপনি একটি স্থায়ী এবং পরিবর্তনশীল মান তৈরি করতে পারেন, তবে এটি একবার মাত্র একবার মাত্র সেট করা যায়।
            final মানগুলি রানটাইমে নির্ধারণ করা হয় এবং এগুলি প্রোসেসিং সময়ে তৈরি হয় না।
            final মানগুলি কনস্ট্যান্ট এক্সপ্রেশন হতে হবে না, অর্থাৎ রানটাইমে নির্ধারণ করা যায়।
            উদাহরণ:
            final String authorName = 'John Doe'; 
            final int maxAttempts = 3; 
            কনস্ট্যান্ট বা ফাইনাল মানগুলি একবার সেট করা হয় এবং পরবর্তীতে তাদের মান পরিবর্তন করা যায় না। এই মানগুলি সাধারণভাবে কোডে স্থিত ডেটা নির্ধারণের জন্য ব্যবহৃত হয়, যেগুলি স্থিতিশীল এবং পরিবর্তনশীল না হওয়া উচিত।

            কনস্ট্যান্টের ধরণ
            Literal Constants: এই প্রকারের কনস্ট্যান্টগুলি সরাসরি মান দ্বারা ডিফাইন করা হয়। এগুলি অবশ্যই কোন ধরণের ভেরিয়েবলে স্টোর করা হয় না।
            int age = 25; // এখানে 25 হলো Literal Constant 
            double pi = 3.1416; // এখানে 3.1416 হলো Literal Constant 
            String name = "John"; // এখানে "John" হলো Literal Constant 

            Compile-time Constants: এই প্রকারের কনস্ট্যান্টগুলি কোড কম্পাইল সময়েই মূল্য প্রাপ্ত করে, এবং প্রোগ্রাম রানটাইমে মান পরিবর্তন করা যায় না।
            const int count = 10; // এই কনস্ট্যান্টটি Compile-time Constant 
            const double gravity = 9.8; // এই কনস্ট্যান্টটি Compile-time Constant 

            Runtime Constants: এই প্রকারের কনস্ট্যান্টগুলি রানটাইমে প্রোগ্রাম চালানোর সময় মূল্য প্রাপ্ত করে, কিন্তু এদের মান পরিবর্তন করা যায় না।
            final int maxAttempts = 3; // এই কনস্ট্যান্টটি Runtime Constant 
            final double interestRate = 5.0; // এই কনস্ট্যান্টটি Runtime Constant 

            কনস্ট্যান্টের বৈশিষ্ট্য:
            কনস্ট্যান্টগুলি প্রোগ্রামে একবার ডিফাইন করার পরে তাদের মান পরিবর্তন করা যায় না। কনস্ট্যান্টগুলির মান কোড কম্পাইল সময়ে পরিশোধন প্রাপ্ত করে, যাতে প্রোগ্রাম চালানোর সময় মূল্য পরিবর্তন করা যায় না।
            const অথবা final কিওয়ার্ড ব্যবহার করে কনস্ট্যান্ট ডিফাইন করা হয়।
            কনস্ট্যান্টগুলি প্রিমিটিভ ডেটা টাইপ (int, double, String, bool) বা কাস্টম ক্লাস হতে পারে।
            উদাহরণ:
            const double pi = 3.1416; 
            final String appName = "MyApp"; 
            final int maxUsers = 100; 
            void main() { 
            print(pi); // কনস্ট্যান্ট প্রিন্ট করা হচ্ছে 
            print(appName); // কনস্ট্যান্ট প্রিন্ট করা হচ্ছে 
            print(maxUsers); // কনস্ট্যান্ট প্রিন্ট করা হচ্ছে 
            } 
            মনে রাখা গুরুত্বপূর্ণ যে, সাধারণ ভেরিয়েবলগুলি var অথবা ডেটা টাইপ দিয়ে ডিফাইন করা হয়, এবং তাদের মান পরিবর্তন করা যায়। তবে, কনস্ট্যান্টগুলি const অথবা final দিয়ে ডিফাইন করা হয় এবং তাদের মান পরিবর্তন করা যায় না।
          '''),
  DartBook(
      title: 'নম্বর (Number)',
      description:
          '''নম্বর (Number) ডার্ট ভাষায় সংখ্যাগুলি নির্দিষ্ট ধরণে থাকে এবং কিছু সাধারণ সংখ্যা ধরণের মধ্যে প্রকাশ করা হয়। আপনি ডার্টে নিম্নলিখিত ধরণের সংখ্যা ব্যবহার করতে পারেন:
              পূর্ণসংখ্যা (Integers): পূর্ণসংখ্যা ডার্টে int ধরণে প্রকাশ করা হয় এবং সম্পূর্ণ সংখ্যাগুলির সেট হলো {..., -3, -2, -1, 0, 1, 2, 3, ...}।
              উদাহরণ:
              int age = 25; 
              int numberOfApples = 10; 

              দশমিক সংখ্যা (Double): দশমিক সংখ্যা ডার্টে double ধরণে প্রকাশ করা হয় এবং দশমিক পুর্নসংখ্যা বা দশমিক অংশ থাকতে পারে।
              উদাহরণ:
              double pi = 3.1416; 
              double temperature = 25.5; 

              কম্প্লেক্স সংখ্যা (Complex Numbers): ডার্টে আপনি num ধরণের মাধ্যমে কম্প্লেক্স সংখ্যা প্রকাশ করতে পারেন। এটি মজাদার দশমিক সংখ্যা সহ অসংখ্যাত অংশ ধরে।
              উদাহরণ:
              num realPart = 5; 
              num imaginaryPart = 3.14; 
              num complexNumber = realPart + imaginaryPart; 

              ২-সাংখ্যিক সিস্টেম (Binary): ডার্টে আপনি সংখ্যা দুটির মধ্যে "0b" প্রিফিক্স ব্যবহার করে ২-সাংখ্যিক সিস্টেমে সংখ্যা প্রকাশ করতে পারেন।
              উদাহরণ:
              int binaryNumber = 0b1010; // ডেসিম্যালে 10 

              ৮-সাংখ্যিক সিস্টেম (Octal): ডার্টে আপনি সংখ্যা দুটির মধ্যে "0o" প্রিফিক্স ব্যবহার করে ৮-সাংখ্যিক সিস্টেমে সংখ্যা প্রকাশ করতে পারেন।
              উদাহরণ:
              int octalNumber = 0o12; // ডেসিম্যালে 10 

              ১৬-সাংখ্যিক সিস্টেম (Hexadecimal): ডার্টে আপনি সংখ্যা দুটির মধ্যে "0x" প্রিফিক্স ব্যবহার করে ১৬-সাংখ্যিক সিস্টেমে সংখ্যা প্রকাশ করতে পারেন।
              উদাহরণ:
              int hexNumber = 0x1A; // ডেসিম্যালে 26 

              ডার্টে সংখ্যা প্রকাশের জন্য আরও কিছু উপযুক্ত মেথড এবং অপারেটর ব্যবহার করা যায়, যাতে আপনি সংখ্যাগুলির সাথে বিভিন্ন গণনা সম্পর্কিত কাজ সম্পাদনা করতে পারেন।
              '''),
  DartBook(
      title: 'স্ট্রিং (String)',
      description:
          '''স্ট্রিং (String) ডার্টে টেক্সট ডেটা প্রকাশ করার জন্য ব্যবহৃত হয়। এটি একাধিক অক্ষর, শব্দ বা সংখ্যার সিকোয়েন্স হতে পারে এবং এটি ডাবল কোটেশন ("") বা সিঙ্গল কোটেশন ('') এর মধ্যে প্রকাশ করা হয়। নিম্নলিখিত উপায়ে স্ট্রিং তৈরি করা যেতে পারে:
            ডাবল কোটেশনে স্ট্রিং:
            String name = "Alice";

            সিঙ্গল কোটেশনে স্ট্রিং:
            String message = 'Hello, World!'; 

            মাল্টিলাইন স্ট্রিং:
            স্ট্রিংগুলি মাল্টিলাইন হতে পারে এবং সিঙ্গল বা ডাবল কোটেশনের মধ্যে না পরেও স্ট্রিং নির্দেশ করতে পারে।
            String multilineString = ' ' ' This is a multiline string in Dart. ' ' '; 

            অথবা
            String multilineString = """ This is another multiline string in Dart. """; 
            স্ট্রিং অপারেশন: স্ট্রিং অপারেশনে ডার্ট ব্যবহার করে স্ট্রিং সাথে কাজ করতে পারে। নিম্নলিখিত অপারেশনগুলি স্ট্রিং সাথে ব্যবহৃত হয়:
            স্ট্রিং সংযোজন (String Concatenation): দুটি স্ট্রিং সংযোজন করার জন্য + অপারেটর ব্যবহার করা যেতে পারে।
            String firstName = "John"; 
            String lastName = "Doe"; 
            String fullName = firstName + " " + lastName; 

            স্ট্রিং ইন্টারপোলেশন (String Interpolation): স্ট্রিং একটি অপারেশনের মধ্যে ভ্যারিয়েবল বা এক্সপ্রেশন সংযোজনের জন্য DolarSign { } সিনট্যাক্স ব্যবহার করা যেতে পারে।
            String name = "Alice"; 
            int age = 30; 
            String message = "My name is $name and I am $age years old."; 

            স্ট্রিং লেংথ (String Length): স্ট্রিং এর দৈর্ঘ্য (অক্ষরের সংখ্যা) জানতে length প্রপার্টি ব্যবহার করা যেতে পারে।
            String text = "Hello, World!"; 
            int length = text.length; // লেংথ হলো 13 

            স্ট্রিং স্লাইসিং (String Slicing): স্ট্রিং থেকে একটি উপস্থিত অংশ বের করতে substring() মেথড বা স্ট্রিং ইন্ডেক্স ব্যবহার করা যেতে পারে।
            String text = "Hello, World!"; 
            String substring1 = text.substring(0, 5); // "Hello" 
            String substring2 = text.substring(7); // "World!" 

            স্ট্রিং মৌলিক অপারেশন (String Methods): ডার্টে একে অপরের সাথে সম্পৃক্ত যেকোনো স্ট্রিং অপারেশন সম্পর্কিত মেথড বা ফাংশন সহযোগী দেয়। উদাহরণস্বরূপ, toUpperCase() মেথড ব্যবহার করে স্ট্রিংটির সব অক্ষর মৌলিক হাতে পরিণত করা যেতে পারে:
            String text = "hello"; 
            String upperCaseText = text.toUpperCase(); // "HELLO" 

            স্ট্রিং এস্কেপ সিকোয়েন্স: কিছু স্পেশাল স্ট্রিং ক্যারেক্টারের জন্য এস্কেপ সিকোয়েন্স ব্যবহার করা যেতে পারে, যেমন:
            \n: নিউলাইন চিহ্ন (লাইন নিয়মন পরিবর্তন করে)।
            \t: ট্যাব চিহ্ন (স্পেস ট্যাবের মধ্যে)।
            \\: এস্কেপ চিহ্ন স্ট্রিংটে প্রকাশ করতে।
            উদাহরণ:
            String multiLineText = "Line 1\nLine 2"; 
            String path = "C:\\Windows\\System32"; 

            স্ট্রিং ডেটা ডার্ট প্রোগ্রামে গুরুত্বপূর্ণ অংশ হতে পারে কারণ এটি টেক্সট ডেটা সংজ্ঞা করে এবং বিভিন্ন ধরণের অপারেশনের জন্য ব্যবহার করা যেতে পারে।
            '''),
  DartBook(
      title: 'বুলিয়ান (Boolean)',
      description:
          '''বুলিয়ান (Boolean) ডার্ট প্রোগ্রামিং ভাষায় একটি ডেটা টাইপ, যা শুধু দুটি মান সমর্থন করে - সত্য (true) এবং মিথ্যা (false)। বুলিয়ান মানের ব্যবহার সবথেকে প্রাথমিক এবং গুরুত্বপূর্ণ কাজে আসে, যেমন লজিক কন্ডিশন চেক করা, স্টেটমেন্ট এক্সিকিউশন কন্ট্রোল, এবং আরও অনেক কিছু।
            বুলিয়ান ডেটা টাইপ ডার্টে একটি ভেরিয়েবলে সত্য বা মিথ্যা মান সংরক্ষণ করে নেয়। সাধারণভাবে, যখন আপনি কোন লজিক অপারেশন (যেমন, সমীকরণ চেক বা তুলনা) করেন, তখন আপনি একটি বুলিয়ান মান পেতে পারেন, যা সত্য বা মিথ্যা হতে পারে।
            ডার্ট প্রোগ্রামে, বুলিয়ান মানের চেক করতে সাধারণভাবে অপারেটর বা লজিকাল স্টেটমেন্ট ব্যবহার করা হয়, এবং এই মান স্টেটমেন্টের শর্তের সাথে মিলানো হয়। এই প্রথমিক বুলিয়ান মানগুলি সত্য এবং মিথ্যা বলে দেওয়া যায়:
            true: এটি সত্য মান প্রতিনিয়ত দেওয়া হয়।
            false: এটি মিথ্যা মান প্রতিনিয়ত দেওয়া হয়।
            উদাহরণ:
            bool isRaining = true;
            bool isSunny = false; 

            উপরের উদাহরণে, আমরা দুটি বুলিয়ান ভেরিয়েবল ডিফাইন করেছি: isRaining এবং isSunny। isRaining এর মান true এবং isSunny এর মান false।
            বুলিয়ান মান ব্যবহার হয় শর্তের সাথে এবং লজিকাল স্টেটমেন্টে যেহেতু সত্যতা বা মিথ্যা প্রতিস্থাপন করে সেজন্য। নিম্নলিখিত কিছু উদাহরণ:
            bool isRaining = true; 
            bool isSunny = false; 
            if (isRaining) { 
            print("বৃষ্টি পড়ছে"); 
            } 
            if (!isSunny) { 
            print("সূর্য বাদ দিচ্ছে"); 
            } 

            উপরের উদাহরণে, আমরা বুলিয়ান মান ব্যবহার করেছি if স্টেটমেন্টে সরবরাহ করতে। isRaining যদি true হয়, তবে "বৃষ্টি পড়ছে" মেসেজটি প্রিন্ট হয়। আবার, isSunny যদি false হয়, তবে "সূর্য বাদ দিচ্ছে" মেসেজটি প্রিন্ট হয়।
            '''),
  DartBook(
      title: 'লিস্ট (List)',
      description:
          '''লিস্ট (List) ডার্টে ডেটা এলিমেন্টগুলির সাধারণ সংকলন প্রকাশ করতে ব্যবহৃত হয়। লিস্টের প্রত্যেকটি এলিমেন্ট একটি স্পেসিফিক ইনডেক্স দ্বারা প্রাপ্ত করা যেতে পারে, এবং সেগুলি সাধারণভাবে পরিচালিত হতে পারে। এই ইনডেক্স সংখ্যা 0 থেকে শুরু হয়।
            লিস্ট তৈরি করতে ডার্টে List ক্লাস বা ব্র্যাকেট [] ব্যবহার করা যেতে পারে। লিস্ট এলিমেন্ট গুলি কমা দ্বারা আলাদা করা হয় এবং স্কোপ প্রাপ্ত করার জন্য ব্র্যাকেট বা elementAt() মেথড ব্যবহার করা যেতে পারে।
            উদাহরণ:
            // একটি লিস্ট তৈরি করা 
            List<int> numbers = [1, 2, 3, 4, 5]; // একটি ফাংশন যাতে লিস্টের একটি ইলিমেন্ট প্রাপ্ত করা হয় 
            int getFirstElement(List<int> list) { return list[0]; } // লিস্টের একটি ইলিমেন্ট প্রাপ্ত করা 
            int firstElement = numbers[0]; // 1 
            int secondElement = numbers[1]; // 2 // লিস্টের প্রথম এবং দ্বিতীয় এলিমেন্ট যোগ করা 
            int sum = numbers[0] + numbers[1]; // 3 // লিস্টের প্রথম এলিমেন্ট পরিবর্তন করা 
            numbers[0] = 10; // [10, 2, 3, 4, 5]

            লিস্টের মৌলিক অপারেশন এবং ব্যবহার:
            লিস্টে উপাদান যোগ করা (Adding Elements to a List): একটি লিস্টে নতুন উপাদান যোগ করতে add() মেথড ব্যবহার করা যেতে পারে।
            List<String> fruits = ["apple", "banana", "cherry"]; fruits.add("date"); 

            লিস্টে ইনডেক্স দ্বারা উপাদান এক্সেস (Accessing Elements by Index): লিস্টের ইনডেক্স ব্যবহার করে নির্দিষ্ট উপাদানে এক্সেস করা যেতে পারে।
            List<int> numbers = [10, 20, 30, 40, 50]; 
            int firstNumber = numbers[0]; // 10 
            int thirdNumber = numbers[2]; // 30 

            লিস্টের দৈর্ঘ্য (Length of a List): লিস্টের দৈর্ঘ্য (উপাদানের সংখ্যা) জানতে length প্রপার্টি ব্যবহার করা যেতে পারে।
            List<String> fruits = ["apple", "banana", "cherry"]; 
            int numberOfFruits = fruits.length; // 3 

            লিস্টে উপাদান পরিবর্তন (Modifying Elements in a List): লিস্টের নির্দিষ্ট ইনডেক্সে উপাদান পরিবর্তন করতে পারেন।
            List<int> numbers = [1, 2, 3, 4, 5]; 
            numbers[1] = 10; // [1, 10, 3, 4, 5] 

            লিস্টের উপাদান মুছে ফেলা (Removing Elements from a List): লিস্ট থেকে নির্দিষ্ট উপাদান মুছে ফেলতে remove() মেথড ব্যবহার করা যেতে পারে।
            List<String> fruits = ["apple", "banana", "cherry"]; 
            fruits.remove("banana"); // ["apple", "cherry"] 

            লিস্টে সর্ট করা (Sorting a List): লিস্টের উপাদানগুলি সর্ট করতে sort() মেথড ব্যবহার করা যেতে পারে।
            List<int> numbers = [5, 1, 4, 2, 3]; 
            numbers.sort(); // [1, 2, 3, 4, 5] 

            লিস্টের মৌলিক অপারেশন (List Methods): লিস্টের সাথে বিভিন্ন অপারেশন পরিচালনার জন্য ডার্ট একে অপরের সাথে সম্পৃক্ত মেথড বা ফাংশন সরবরাহ করে। উপরের উদাহরণের মধ্যে কিছু মেথড দেওয়া হয়েছে, যেগুলি লিস্টে কাজ করতে সাহায্য করে।
            উদাহরণ:
            add(): লিস্টে নতুন উপাদান যোগ করতে ব্যবহার করা হয়।
            remove(): লিস্ট থেকে নির্দিষ্ট উপাদান মুছে ফেলতে ব্যবহার করা হয়।
            sort(): লিস্টের উপাদানগুলি সর্ট করতে ব্যবহার করা হয়।
            লিস্ট ডার্টে একটি প্রায় সমপর্ণভাবে ব্যবহৃত ডেটা স্ট্রাকচার এবং অনেক প্রোগ্রামের সময় মৌলিক হিসেবে ব্যবহৃত হয়। লিস্টের উপাদান যোগ, সর্ট, পরিবর্তন এবং মুছে ফেলার সাধারণ অপারেশনগুলি অনেক গুরুত্বপূর্ণ হতে পারে প্রোগ্রামের যাতে ডেটা স্ট্রাকচারটি সঠিকভাবে ব্যবহার করা যায়।
            '''),
  DartBook(
      title: 'সেট (Set)',
      description:
          '''সেট (Set) ডার্টে ইউনিক এলিমেন্টগুলির একটি সাধারণ সংকলন প্রকাশ করতে ব্যবহৃত হয়। সেটে একই এলিমেন্ট একাধিক বার থাকতে পারে না, অতএব সেটে শুধুমাত্র ইউনিক এলিমেন্ট থাকে। সেটে ইলিমেন্ট কোন নির্দিষ্ট ক্রমে থাকতে পারে না, অর্থাৎ সেটের এলিমেন্ট সাধারণভাবে আদেশিত নয়।
              সেট তৈরি করতে ডার্টে Set ক্লাস বা ব্র্যাকেট {} ব্যবহার করা যেতে পারে। সেটের এলিমেন্ট গুলি কমা দ্বারা আলাদা করা হয় এবং কোন ইলিমেন্ট সেটে দ্বিতীয়বার যোগ করলে কোন প্রতিক্রিয়া দেয় না।
              উদাহরণ:
              // একটি সেট তৈরি করা 
              Set<String> colors = {"red", "green", "blue"}; // নতুন ইলিমেন্ট সেটে যোগ করা 
              colors.add("yellow"); // দ্বিতীয়বার একই ইলিমেন্ট সেটে যোগ করা (কোন প্রতিক্রিয়া দেয় না) 
              colors.add("red"); // সেট লেংথ (ইলিমেন্টের সংখ্যা) জানা 
              int length = colors.length; // 4 
              সেটে ইলিমেন্ট যোগ করতে add() মেথড ব্যবহার করা যেতে পারে এবং সেটের লেংথ (ইলিমেন্টের সংখ্যা) জানতে length প্রোপার্টি ব্যবহার করা যেতে পারে।

              সেটের সাথে কিছু গুরুত্বপূর্ণ অপারেশন সম্পর্কিত মেথড ও প্রোপার্টি রয়েছে:
              সেটের লেংথ (Set Length): সেটের এলিমেন্ট সংখ্যা জানতে length প্রোপার্টি ব্যবহার করা যেতে পারে।
              Set<String> fruits = {"apple", "banana", "cherry"}; 
              int length = fruits.length; // 3 

              এলিমেন্ট যোগ করা (Adding Elements): নতুন এলিমেন্ট সেটে যোগ করার জন্য add() মেথড ব্যবহার করা যেতে পারে। যদি সেটে ইতিমধ্যে এই এলিমেন্ট থাকে, তাদের কোন প্রভাব থাকে না এবং সেটে একই এলিমেন্ট দুটি সহ থাকে না।
              Set<String> colors = {"red", "blue"}; 
              colors.add("green"); // {"red", "blue", "green"} 
              colors.add("red"); // কোন প্রভাব পড়ে না 

              এলিমেন্ট অপশন করা (Removing Elements): সেট থেকে এলিমেন্ট অপশন করার জন্য remove() মেথড ব্যবহার করা যেতে পারে।
              Set<String> colors = {"red", "blue", "green"}; 
              colors.remove("blue"); // {"red", "green"} 

              সেটের সম্প্রেষণ (Set Operations): সেটের মধ্যে সম্প্রেষণ অপারেশন প্রদান করা হয়, যেমন ইউনিয়ন, ইন্টারসেকশন, সাবসেট সম্প্রেষণ, ইত্যাদি।
              উদাহরণ:
              Set<int> set1 = {1, 2, 3, 4, 5}; 
              Set<int> set2 = {3, 4, 5, 6, 7}; 

              // ইউনিয়ন (Union) দুটি সেটের সব ইলিমেন্ট যোগ করে 
              Set<int> unionSet = set1.union(set2); // {1, 2, 3, 4, 5, 6, 7} 

              // ইন্টারসেকশন (Intersection) দুটি সেটের যেসব ইলিমেন্ট একই আছে তা প্রকাশ করে 
              Set<int> intersectionSet = set1.intersection(set2); // {3, 4, 5} 

              //সাবসেট (Subset) একটি সেট আরেকটি সেটের সাবসেট কিনা যাচাই করতে 
              bool isSubset = set1.isSubsetOf(set2); // false 

              সেট ডাটা স্ট্রাকচার ডার্টে ডাটা অনুসন্ধান এবং ডুপ্লিকেট এলিমেন্টগুলি সংরক্ষণ করতে ব্যবহৃত হয়। এটি ইউনিক এলিমেন্ট সংরক্ষণের জন্য ব্যবহার করা যেতে পারে, এমনকি যখন আপনি দুটি এলিমেন্টের ইকুয়ালিটি পরীক্ষা করতে চান।
              সেট ডেটা ডার্টে উপযুক্ত অপারেশনের সুবিধা দেয় যেগুলি অন্যান্য ডেটা স্ট্রাকচারের সাথে সম্পর্কিত না। এটি সম্পূর্ণরূপে ইনডেক্সের নেই, এবং একটি ইলিমেন্ট সেটে একবার মাত্র থাকতে পারে।
              '''),
  DartBook(
      title: 'ম্যাপ (Map)',
      description:
          '''ম্যাপ (Map) ডার্টে ইউনিক কী-ভ্যালু জোড়াও বা ম্যাপ কী-মান প্যার সংকলন প্রকাশ করতে ব্যবহৃত হয়। ম্যাপে প্রত্যেক কী একটি ইউনিক ভ্যালুর সাথে সংযোজিত থাকে। ম্যাপে কোন ইউনিক কী একাধিক বার থাকতে পারে না, অতএব ম্যাপে শুধুমাত্র ইউনিক কী গুলি থাকে।
            ম্যাপ তৈরি করতে ডার্টে Map ক্লাস বা ব্র্যাকেট {} ব্যবহার করা যেতে পারে। ম্যাপে কী-মান জোড়াগুলি কোমা দ্বারা আলাদা করা হয় এবং কোন কী-মান ম্যাপে দ্বিতীয়বার যোগ করলে পূর্বের মান পরিবর্তন হয়।
            উদাহরণ:
            // একটি ম্যাপ তৈরি করা 
            Map<String, int> ages = { "Alice": 25, "Bob": 30, "Charlie": 28, }; // নতুন কী-মান পেয়ার ম্যাপে যোগ করা 
            ages["David"] = 22; // কী দ্বারা মান প্রাপ্ত করা 
            int aliceAge = ages["Alice"]; // 25 
            int bobAge = ages["Bob"]; // 30 

            ম্যাপে প্রতিটি কী-মান পেয়ারের একটি কী থেকে মান প্রাপ্ত করতে কী ব্যবহার করা যেতে পারে।
            ম্যাপের সাথে কিছু গুরুত্বপূর্ণ অপারেশন সম্পর্কিত মেথড ও প্রোপার্টি রয়েছে:
            কী-মান পেয়ার সংখ্যা (Number of Key-Value Pairs): ম্যাপে কতগুলি কী-মান পেয়ার আছে তা জানতে length প্রোপার্টি ব্যবহার করা যেতে পারে।
            Map<String, int> scores = { "Alice": 95, "Bob": 80, "Charlie": 75, }; 
            int numberOfPairs = scores.length; // 3 

            কী-মান যোগ করা (Adding Key-Value Pairs): নতুন কী-মান পেয়ার ম্যাপে যোগ করার জন্য addAll() মেথড ব্যবহার করা যেতে পারে।
            Map<String, int> scores = { "Alice": 95, "Bob": 80, }; 
            scores.addAll({"Charlie": 75, "David": 90}); 

            কী-মান অপশন করা (Removing Key-Value Pairs): কোন কী-মান পেয়ার ম্যাপ থেকে অপশন করার জন্য remove() মেথড ব্যবহার করা যেতে পারে।
            Map<String, int> scores = { "Alice": 95, "Bob": 80, "Charlie": 75, }; 
            scores.remove("Charlie"); 

            কী-মান এইটারেশন (Iterating through Key-Value Pairs): ম্যাপের কী-মান পেয়ার গুলির উপর ইটারেট করতে forEach() মেথড ব্যবহার করা যেতে পারে।
            Map<String, int> scores = { "Alice": 95, "Bob": 80, "Charlie": 75, }; 
            scores.forEach((key, value) { print("$key's score is $value"); }); 
            ম্যাপ ডার্টে গুরুত্বপূর্ণ ডাটা স্ট্রাকচার, কনফিগারেশন, এবং ডেটা ম্যানিপুলেশনে ব্যবহৃত হতে পারে, এবং সেটের সাথে তুলনায় বিশেষভাবে উপযোগী।
          '''),
  DartBook(
      title: 'রুন (Runes)',
      description:
          '''রুন (Runes) ডার্টে ইউনিকোড ক্যারেক্টার স্ট্রিং বা ইউনিকোড পয়েন্টস প্রকাশ করতে ব্যবহৃত হয়। ইউনিকোড একটি একক বা একাধিক ক্যারেক্টারের সিকোয়েন্স বা কোড পয়েন্ট বা প্রতিস্থান নাম ব্যবহার করে প্রকাশ করা যেতে পারে, এবং এগুলি স্ট্রিং এর মধ্যে বা কোডে এক্সপ্রেশন হিসেবে ব্যবহৃত হতে পারে।
            ডার্টে, রুন সিম্বল একটি পোস্টিভ পূর্ণ সংখ্যা হয়, যেটি ইউনিকোড পয়েন্টস কে প্রতিনির্দিষ্ট সংখ্যায় প্রতিষ্ঠাপন করে। এই রুন সিম্বল ব্যবহার করে ইউনিকোড ক্যারেক্টার স্ট্রিং বা পয়েন্টস তৈরি করা যেতে পারে।
            একটি স্ট্রিং এ রুন সিম্বল ব্যবহার করতে, তাকে একটি ব্যাকস্ল্যাশ (\) এবং ইউনিকোড পয়েন্ট সংখ্যায় প্রতিষ্ঠাপন করতে হয়।
            উদাহরণ:
            String heart = '\u2764'; // হৃদয় চিহ্ন (Heart Symbol) 
            String smiley = '\u{1F604}'; // স্মাইলি চিহ্ন (Smiling Face with Open Mouth and Smiling Eyes) 
            রুন সিম্বল স্ট্রিং এ মধ্যে একাধিক ক্যারেক্টার থাকতে পারে এবং স্ট্রিং স্ট্রিং এর মধ্যে প্রিন্ট করতে হলে এটিকে প্রিন্ট স্টেটমেন্টে ব্যবহার করতে হয়:
            String greeting = 'হ্যালো, কেমন আছো?'; 
            print(greeting); 
            রুন সিম্বল এর উপর স্ট্রিং মেথড ও অপারেটর অনুমোদিত এবং এটি ইউনিকোড ক্যারেক্টার স্ট্রিং বা পয়েন্টস তৈরি করার জন্য ব্যবহার করা যেতে পারে।
            '''),
  DartBook(
      title: 'এনুমেরেশন (Enumeration)',
      description:
          '''এনুমেরেশন (Enumeration) ডার্টে একটি কাস্টম ডেটা টাইপ যা একাধিক স্থানে ব্যবহৃত কন্সটেন্ট মান সংক্রান্ত হয়। Enum ডাটা টাইপ তৈরি করে ডেটা কাস্টম মান সেট সংরক্ষণ করে রাখতে সাহায্য করে এবং প্রোগ্রামে মান সংক্রান্ত নির্দিষ্ট এবং সাবধান কোডিং সুন্দর করে।
              একটি Enum তৈরি করতে আপনি enum কীওয়ার্ড ব্যবহার করতে হয় এবং Enum এর সদস্য মানগুলি কমা দ্বারা আলাদা করে প্রদান করতে হয়।
              উদাহরণ:
              enum Weekday { monday, tuesday, wednesday, thursday, friday, saturday, sunday, } 

              উপরের Enum ডেফিনেশনে, Weekday হলো Enum এর নাম এবং এর সদস্য মান হলো monday, tuesday, ইত্যাদি। এই Enum এর সদস্য মান সাধারণভাবে স্থানীয় চরিত্রের অক্ষরিক নামে দেওয়া হয়, সাধারণভাবে স্মল লেটারে।
              Enum এর মান প্রাপ্ত করতে, আপনি Enum এর সদস্য মান নামে ডট নোটেশন ব্যবহার করতে পারেন:
              Weekday today = Weekday.monday; 

              Enum তে ইন্ডেক্স নাম দ্বারা প্রতিস্থাপন করা যেতে পারে:
              Weekday today = Weekday.values[0]; // এটি monday কে নির্দিষ্ট করে 

              Enum এর সদস্য মান পুনরায় ব্যবহার করার জন্য একটি switch স্টেটমেন্ট বা if-else স্টেটমেন্ট ব্যবহার করা সুন্দর:
              Weekday today = Weekday.thursday; 
              switch (today) { 
                case Weekday.monday: print("সোমবার"); 
                break; 
                case Weekday.tuesday: print("মঙ্গলবার"); 
                break; // অন্য সমস্যা সদস্য মান যোগ করুন default: print("সাপ্তাহিক দিন"); 
              } 
              Enum ডাটা টাইপ সাধারণভাবে প্রোগ্রামের বুঝতে সাহায্য করে এবং কোড বুঝতে সাহায্য করে, যেহেতু এটি নির্দিষ্ট মান সেট সংরক্ষণ করে রাখে।
              '''),
  DartBook(
      title: 'কন্ট্রোল ফ্লো স্টেটমেন্ট (Control Flow Statement) ',
      description:
          '''কন্ট্রোল ফ্লো স্টেটমেন্ট (Control Flow Statement) ডার্ট প্রোগ্রামে প্রোগ্রাম এবং তথ্য নিয়ন্ত্রণ করার জন্য ব্যবহৃত হয়। এই স্টেটমেন্টগুলি প্রোগ্রামের বিভিন্ন অংশের সামঞ্জস্য স্থাপন করে থাকে, যেহেতু একটি সিদ্ধান্ত নেয়া যায় যে কোন শর্ত অনুসরণ করতে হবে। নিম্নলিখিত ডার্ট কন্ট্রোল ফ্লো স্টেটমেন্টগুলির ব্যাখ্যা:
              শর্তানুসরণ (if-else): এই স্টেটমেন্ট দিয়ে আপনি একটি শর্তের উপর ভিত্তি করে কোন কাজ করতে পারেন। যদি শর্ত সত্য হয়, তাহলে if ব্লক এর কোড ব্লক চলবে, অন্যথায় else ব্লক এর কোড চলবে।
              if (condition) { // শর্ত সত্য হলে এই ব্লক চলবে }
              else { // শর্ত মিথ্যা হলে এই ব্লক চলবে } 

              সুইচ স্টেটমেন্ট (switch): সুইচ স্টেটমেন্ট একটি একাধিক মান যাচাই করতে ব্যবহৃত হয় এবং সম্পর্কিত ব্লকে যায় তার উপর ভিত্তি করে একটি ব্লকে কোন কাজ করে।
              switch (value) { 
                case 1: // যদি মান 1 হয় 
                break; 
                case 2: // যদি মান 2 হয় 
                break; 
                default: // যদি কোন ম্যাচ না পাওয়া যায় 
              } 

              ফর লুপ (for loop): ফর লুপ দিয়ে আপনি একটি বিশেষ কাজ কে প্রতিবার একটি নির্দিষ্ট সংখ্যক বার করতে পারেন।
              for (var i = 0; i < 5; i++) { // এই ব্লক প্রতিবার 5 বার চলবে } 

              ফর-ইন লুপ (for-in loop): ফর-ইন লুপ দিয়ে আপনি একটি সংগ্রহণ (যেমন List, Map) এর প্রতিটি এলিমেন্ট এর উপর কাজ করতে পারেন।
              List<int> numbers = [1, 2, 3, 4, 5]; 
              for (var number in numbers) { // প্রতিটি সংখ্যা এই ব্লকে চলবে } 

              ওয়াইল লুপ (while loop): ওয়াইল লুপ দিয়ে আপনি একটি শর্ত পর্যন্ত কাজ করতে পারেন, এবং যতটুকু তার মাধ্যমে শর্ত সত্য থাকে তাতে লুপ চলতে থাকবে।
              while (condition) { // এই ব্লক শর্ত সত্য থাকতে পর্যন্ত চলবে } 

              ডু-ওয়াইল লুপ (do-while loop): ডু-ওয়াইল লুপ একটি ব্লক কে প্রথমে একবার চালাবে এবং তারপরে শর্ত পর্যন্ত কাজ করবে।
              do { // এই ব্লক প্রথমে একবার চলবে এবং শর্ত সত্য থাকতে পর্যন্ত চলবে } 
              while (condition); 
              এই কন্ট্রোল ফ্লো স্টেটমেন্টগুলি ডার্টের প্রোগ্রামে ব্যবহৃত হয় এবং প্রোগ্রামের বিভিন্ন অংশে লজিক বা বিশেষ টাস্ক বাস্তবায়ন করতে সাহায্য করে।
              '''),
  DartBook(
      title: 'if স্টেটমেন্ট (if Statement)',
      description:
          '''if স্টেটমেন্ট (if Statement) ডার্ট প্রোগ্রামিং ভাষায় একটি কন্ট্রোল ফ্লো স্টেটমেন্ট যা একটি শর্ত চেক করে এবং শর্ত সত্য হলে নির্দিষ্ট কোড ব্লক বা স্টেটমেন্ট চালায়। যদি শর্ত মিথ্যা হয়, তাহলে কোন কোড ব্লক বা স্টেটমেন্ট চালানো হয় না।
              এটির সিনট্যাক্স:
              if (condition) { // শর্ত সত্য হলে এই ব্লক চলবে } 
              উদাহরণ দেখা যাক:
              void main() { 
                int age = 18; 
                if (age >= 18) { 
                  print("আপনি ভোট দিতে পারবেন"); 
                } 
                print("প্রোগ্রাম শেষ!"); 
              } 

              উপরের উদাহরণে, প্রোগ্রামের প্রথম লাইনে আমরা age নামে একটি ভেরিয়েবল ডিফাইন করেছি এবং তার মান 18 দেওয়া হয়েছে। তারপরে, আমরা if স্টেটমেন্ট ব্যবহার করেছি যাতে চেক করা যায় যদি age 18 বা তার চেয়ে বড় হয়, তাহলে "আপনি ভোট দিতে পারবেন" মেসেজটি প্রিন্ট হবে।
              এটি প্রিন্ট স্টেটমেন্টের পরে এসে "প্রোগ্রাম শেষ!" মেসেজটি প্রিন্ট হবে, সম্ভবত শর্তটি সত্য ছিল তাই শর্ত সত্য হলে কোড ব্লক চলানো হয়েছিল।
              আপনি else স্টেটমেন্ট ব্যবহার করে এই শর্ত মিথ্যা হলে একটি আলাদা কোড ব্লক বা স্টেটমেন্ট চালাতে পারেন:
              void main() { 
                int age = 16; 
                if (age >= 18) { 
                  print("আপনি ভোট দিতে পারবেন"); 
                } 
                else { 
                  print("আপনি ভোট দিতে পারবেন না"); 
                } 
                print("প্রোগ্রাম শেষ!"); 
              } 

              উপরের উদাহরণে, শর্তটি মিথ্যা হয়েছে তাই else ব্লকের কোড চলানো হয়েছে এবং তাতে "আপনি ভোট দিতে পারবেন না" মেসেজটি প্রিন্ট হয়েছে।

              এটি মৌলিকভাবে শর্তের উপর নির্ভর করে কোড ব্লক চালানোর সাধারণ উপায়।
              '''),
  DartBook(
      title: 'if-else স্টেটমেন্ট (if-else Statement)',
      description:
          '''if-else স্টেটমেন্ট (if-else Statement) ডার্ট প্রোগ্রামিং ভাষায় একটি কন্ট্রোল ফ্লো স্টেটমেন্ট যা একটি শর্ত চেক করে এবং শর্ত সত্য হলে একটি নির্দিষ্ট কোড ব্লক বা স্টেটমেন্ট চালায়। যদি শর্ত মিথ্যা হয়, তাহলে অন্য একটি নির্দিষ্ট কোড ব্লক বা স্টেটমেন্ট চালায়।
            এটির সিনট্যাক্স:
            if (condition) { // শর্ত সত্য হলে এই ব্লক চলবে } 
            else { // শর্ত মিথ্যা হলে এই ব্লক চলবে } 
            উদাহরণ দেখা যাক:
            void main() { 
              int age = 16; 
              if (age >= 18) {
                print("আপনি ভোট দিতে পারবেন"); 
              } 
              else { 
                print("আপনি ভোট দিতে পারবেন না"); 
              } 
              print("প্রোগ্রাম শেষ!"); 
            } 

            উপরের উদাহরণে, প্রোগ্রামের প্রথম লাইনে আমরা age নামে একটি ভেরিয়েবল ডিফাইন করেছি এবং তার মান 16 দেওয়া হয়েছে। তারপরে, আমরা if স্টেটমেন্ট ব্যবহার করেছি যাতে চেক করা যায় যদি age 18 বা তার চেয়ে বড় হয়, তাহলে "আপনি ভোট দিতে পারবেন" মেসেজটি প্রিন্ট হবে। মিথ্যা শর্তে, অন্যথায় else ব্লকের কোড চলানো হবে এবং তাতে "আপনি ভোট দিতে পারবেন না" মেসেজটি প্রিন্ট হবে।
            প্রোগ্রামের শেষে "প্রোগ্রাম শেষ!" মেসেজটি প্রিন্ট হয়, সম্ভবত শর্তটি মিথ্যা ছিল, সেই কারণে else ব্লকের কোড চলানো হয়েছিল।
            এই ভাবে, if-else স্টেটমেন্ট ব্যবহার করে আপনি প্রোগ্রামের বিভিন্ন স্থিতিতে নির্দিষ্ট কোড ব্লক চালাতে পারেন।
            '''),
  DartBook(
      title: 'if-else-if স্টেটমেন্ট (if-else-if Statement)',
      description:
          '''if-else-if স্টেটমেন্ট (if-else-if Statement) ডার্ট ডার্ট প্রোগ্রামিং ভাষায় একটি কন্ট্রোল ফ্লো স্টেটমেন্ট যা একটি শর্ত চেক করে, যদি শর্ত সত্য হয় তবে একটি কোড ব্লক চালিয়ে যায়। যদি প্রথম শর্ত মিথ্যা হয়, তবে একটি আরেকটি শর্ত চেক করা হয়, এবং যদি দ্বিতীয় শর্তটি সত্য হয়, তবে দ্বিতীয় শর্তের মধ্যে থাকা কোড ব্লক চালায়। যদি প্রথম এবং দ্বিতীয় শর্ত উভয়ই মিথ্যা হয়, তবে একটি প্রস্তাবিত শর্তের চেক করা হয় এবং যদি তা সত্য হয়, তাহলে প্রস্তাবিত শর্তের মধ্যে থাকা কোড ব্লক চালায়।
              সিনট্যাক্স:
              if (condition1) { // শর্ত 1 সত্য হলে এই ব্লক চলবে } 
              else if (condition2) { // শর্ত 2 সত্য হলে এই ব্লক চলবে } 
              else { // যদি কোন শর্ত সত্য না হয়, তাহলে এই ব্লক চলবে } 
              উদাহরণ দেখা যাক:
              void main() { 
                int score = 75; 
                if (score >= 90) { 
                  print("A+"); 
                } 
                else if (score >= 80) { 
                  print("A"); 
                } 
                else if (score >= 70) { 
                  print("B"); 
                } else if (score >= 60) { 
                  print("C"); } 
                else { 
                  print("F"); 
                } 
                print("প্রোগ্রাম শেষ!"); 
              } 

              উপরের উদাহরণে, প্রথম লাইনে আমরা score নামে একটি ভেরিয়েবল ডিফাইন করেছি এবং তার মান 75 দেওয়া হয়েছে। তারপরে, আমরা if স্টেটমেন্ট ব্যবহার করেছি যাতে চেক করা যায় যদি score 90 বা তার চেয়ে বড় হয়, তাহলে "A+" মেসেজটি প্রিন্ট হবে। শর্তটি মিথ্যা হলে, আমরা else if স্টেটমেন্ট দ্বারা অন্য শর্তগুলির দিকে চলে যাবো, এবং যদি কোনও শর্ত সত্য হয়, তাতে সম্মিলিত ব্লকের কোড চলানো হবে এবং সে অবস্থায় মেসেজ প্রিন্ট হবে যা সত্য হবে। শেষ অবস্থায়, "প্রোগ্রাম শেষ!" মেসেজটি প্রিন্ট হবে।
              if-else if স্টেটমেন্ট দ্বারা আপনি একটি শর্তের সাথে কোড এর বিভিন্ন আপশনের মধ্যে নির্বাচন করতে পারেন এবং সেই শর্তের উপর নির্ভর করে বিভিন্ন কোড ব্লক চালাতে পারেন।
            '''),
  DartBook(
      title: 'সুইচ কেস স্টেটমেন্ট (Switch Case Statement)',
      description:
          '''সুইচ কেস স্টেটমেন্ট (Switch Case Statement) ডার্ট প্রোগ্রামিং ভাষায় একটি কন্ট্রোল ফ্লো স্টেটমেন্ট, যা একটি মূল মান বা একটি শর্তের সাথে ব্যবহার করে এবং প্রোগ্রামের বিভিন্ন কোড ব্লকের মধ্যে চলানো যেতে পারে। এই স্টেটমেন্ট বুঝতে জনপ্রিয়তম মৌলিক মান বা একটি শর্ত প্রেরণ করে এবং যে মৌলিক মান বা শর্তের সাথে মেলে, তার উপর নির্ভর করে প্রোগ্রামের নির্দিষ্ট অংশ চলাতে সাহায্য করে।
              সুইচ কেস স্টেটমেন্ট সাধারণভাবে নিম্নলিখিত সিনট্যাক্সে ব্যবহার করা হয়:
              switch (expression) { 
                case value1: // মৌলিক মান বা শর্তের সাথে মেলে গেলে এই ব্লক চলবে 
                break; 
                case value2: // মৌলিক মান বা শর্তের সাথে মেলে গেলে এই ব্লক চলবে 
                break; // আরও ক্যাসেস যোগ করতে পারেন 
                default: // কোন মৌলিক মান বা ক্যাসে মেলে না, তাহলে এই ব্লক চলবে 
              }
              
              সুইচ কেস স্টেটমেন্ট একটি এক্সপ্রেশন (expression) নেয়, যা একটি মৌলিক মান বা শর্ত হতে পারে। এই এক্সপ্রেশনের মানের সাথে সার্টেইন কেসের মৌলিক মান বা শর্ত মেলে যাওয়া সম্ভব।
              ক্যাস স্টেটমেন্টের মধ্যে একটি বা একাধিক case প্রদান করা যেতে পারে, যেখানে প্রত্যেকটি case একটি মৌলিক মান বা একটি শর্ত দেয়। যদি সুইচ এক্সপ্রেশনের মান একটি case এর মৌলিক মান বা শর্ত সাথে মেলে, তাহলে সেই case এর ব্লক চলানো হয়। এরপরের কেস গুলি এখানে চেক করা হয় না।
              break স্টেটমেন্ট ব্যবহার করে একটি ক্যাস থেকে বের হতে সাহায্য করে। একটি ক্যাসের ব্লক চলানো শেষ হলে সম্ভবত আপনি স্বয়ংক্রিয়ভাবে স্যানিটাইজ করতে break ব্যবহার করতে চান।
              default কেস একটি ঐচ্ছিক অংশ, যা সুইচ এক্সপ্রেশনের মানের সাথে কোন ম্যাচ না পেলে চলে।
              একটি উদাহরণ দেখা যাক:
              void main() { 
                String day = "Monday"; 
                switch (day) { 
                  case "Monday": print("সোমবার"); 
                  break; 
                  case "Tuesday": print("মঙ্গলবার"); 
                  break; 
                  case "Wednesday": print("বুধবার"); 
                  break; 
                  case "Thursday": print("বৃহস্পতিবার"); 
                  break; case "Friday": print("শুক্রবার"); 
                  break; default: print("সপ্তাহের অন্যান্য দিন"); 
                } 
              } 

              উপরের উদাহরণে, day এক্সপ্রেশনের মান "Monday" হলে "সোমবার" মেসেজটি প্রিন্ট হবে এবং এরপরের ক্যাস গুলি চেক করা হবে না। আমরা break ব্যবহার করে ক্যাসের ব্লক থেকে বের হয়েছি। যদি day এর মান অন্য কোন দিনের সাথে মেলে না, তবে default কেসে চলে যাবে এবং "সপ্তাহের অন্যান্য দিন" মেসেজটি প্রিন্ট হবে।
              সুইচ কেস স্টেটমেন্ট অনেকটা একটি এক্সপ্রেশনের মান বা শর্তের উপর নির্ভর করে বিভিন্ন কোড ব্লক চালাতে সাহায্য করে, এবং এটি মৌলিকভাবে প্রোগ্রামের কন্ট্রোল ফ্লো নির্ধারণ করতে সাহায্য করে।
              '''),
  DartBook(
      title: 'লুপ (Loops)',
      description:
          '''লুপ (Loops) ডার্ট প্রোগ্রামিং ভাষায় একটি অতি গুরুত্বপূর্ণ কন্ট্রোল ফ্লো স্টেটমেন্ট, যার মাধ্যমে একই কোড ব্লক বা স্টেটমেন্ট পুনরায় এবং পুনরায় চালানো যায়। লুপ ব্যবহার করে প্রোগ্রামাররা একাধিক সময়ে একই ধরণের কাজ করতে পারে এবং কোড এর সবচেয়ে ব্যবহারকারী উপকারিতা পেতে পারে।
              ডার্ট ভাষায় তিনটি প্রধান লুপ আছে:
              for লুপ: for লুপ একটি নির্দিষ্ট সংখ্যক বার একই কোড ব্লক চালানোর জন্য ব্যবহার হয়। স্যানট্যাক্স:
              for (initialization; condition; update) { // কোড ব্লক } 
              উদাহরণ:
              for (int i = 1; i <= 5; i++) { 
                print("সংখ্যা: $i"); 
              } 

              while লুপ: while লুপ একটি শর্ত সত্য হলে একই কোড ব্লক চালানোর জন্য ব্যবহার হয়। স্যানট্যাক্স:
              while (condition) { // কোড ব্লক } 
              উদাহরণ:
              int count = 1; while (count <= 5) { 
                print("সংখ্যা: $count"); count++; 
              } 

              do-while লুপ: do-while লুপ একটি কোড ব্লক চালানোর পরে একটি শর্ত পরীক্ষা করে এবং শর্ত সত্য হলে একে বা একাধিক বার কোড ব্লক চালানোর জন্য ব্যবহার হয়। স্যানট্যাক্স:
              do { // কোড ব্লক } 
              while (condition); 
              উদাহরণ:
              int count = 1; do { 
                print("সংখ্যা: $count"); 
              count++; 
              } 
              while (count <= 5); 

              লুপ স্টেটমেন্ট আপনাকে একই কাজগুলি পুনরাবৃত্তি করতে সাহায্য করে, যেহেতু ডার্টে অধিকাংশ প্রোগ্রামিং চুক্তি মৌলিক এবং শর্তের উপর নির্ভর করে।
              '''),
  DartBook(
      title: 'ফর লুপ (For Loop)',
      description:
          '''ফর লুপ (For Loop) ডার্ট প্রোগ্রামিং ভাষায় একটি লুপ স্টেটমেন্ট, যার মাধ্যমে একই কোড ব্লক বা স্টেটমেন্ট একটি নির্দিষ্ট সংখ্যক বার চালানো যায়। ফর লুপ একটি আদিক মান (শুরু মান), একটি শর্ত, এবং একটি ইনক্রিমেন্ট বা ডেক্রিমেন্ট ধারণ করে।
              সিনট্যাক্স:
              for (initialization; condition; increment/decrement) { // লুপের কোড ব্লক } 

              initialization: প্রথমে আদিক মান সেট করা হয়, যা প্রথম লুপ চালানোর আগে একবার চলতে পারে।
              condition: লুপের কোড ব্লক চালানোর আগে প্রতি লুপে এই শর্ত পরীক্ষা করা হয়। যদি শর্ত সত্য হয়, তবে লুপ চলবে; শর্ত মিথ্যা হলে লুপ বন্ধ হয়।

              increment/decrement: প্রতি লুপে লুপের শেষে এই অংশ চালানো হয়। এটি আদিক মান বা শর্তের মান পরিবর্তন করে এবং নতুন লুপে চালানো হয়।
              উদাহরণ দেখা যাক:
              void main() { 
                for (int i = 1; i <= 5; i++) { 
                  print("সংখ্যা: $i"); 
                } 
              } 
              উপরের উদাহরণে, প্রথমে আমরা i নামে একটি ভেরিয়েবল ডিফাইন করেছি এবং এর মান 1 দেওয়া হয়েছে। তারপর, আমরা একটি for লুপ ব্যবহার করেছি যাতে আমরা 1 থেকে 5 পর্যন্ত সংখ্যা প্রিন্ট করতে পারি।

              লুপের প্রতি ইটারেশনে, প্রথমে i এর মান 1 এবং শর্ত i <= 5 সত্য হয়, তাহলে লুপের কোড ব্লক চলে এবং "সংখ্যা: 1" মেসেজটি প্রিন্ট হয়। এরপর, i এর মান 2 এবং এই প্রক্রিয়া চলতে থাকে যতক্ষণ না i 5 এর সমান বা বড় হয়ে যায়।
              এই উদাহরণে, লুপের মাধ্যমে আমরা 1 থেকে 5 পর্যন্ত সংখ্যা প্রিন্ট করেছি। আপনি for লুপের সাথে আপনার প্রোগ্রামের প্রয়োজনে যেকোন কাজ করতে পারেন যা নির্দিষ্ট সংখ্যক বার পুনরায় করতে হবে।
              '''),
  DartBook(
      title: 'ফর-ইন লুপ (For-in Loop)',
      description:
          '''ফর-ইন লুপ (For-in Loop) ডার্ট প্রোগ্রামিং ভাষায় একটি প্রাকৃতিক স্ট্রাকচারের প্রাথমিক উপায়ে এক্সেস করা, এক্সট্র্যাক্ট করা, বা ইটারেট করার জন্য ব্যবহৃত হয়। এই লুপে আপনি একটি নির্দিষ্ট সংখ্যক ইটারেটর প্রাপ্ত করতে পারেন এবং সেগুলির সাথে সংখ্যা, স্ট্রিং, লিস্ট, সেট, ম্যাপ, স্ট্রিম এবং অন্যান্য ইটারেটেবল আইটেমগুলির উপর ইটারেট করতে পারেন।
              সুইচ কেসের সিনট্যাক্স:
              for (var element in iterable) { // লুপের কোড ব্লক }
              
              element: এই ভেরিয়েবলে সমস্ত ইটারেবল আইটেম একটি একটি আসবে, এবং লুপের প্রতি ইটারেশনে এর মান আপডেট হবে।
              iterable: এই আইটেমগুলির সেট, যেগুলি আপনি ইটারেট করতে চান।
              উদাহরণ দেখা যাক:
              void main() { 
                List<int> numbers = [1, 2, 3, 4, 5]; 
                for (var number in numbers) { 
                  print(number); 
                } 
              } 
              উপরের উদাহরণে, আমরা একটি ইন্টিজার লিস্ট numbers ডিফাইন করেছি এবং এই লিস্টের প্রতি ইটারেশনে একটি নম্বর আসে এবং সেটি প্রিন্ট করেছি। সো, লুপের প্রতিইটারেশনে, আমরা 1, 2, 3, 4, এবং 5 এই নম্বরগুলি প্রিন্ট করতে পাই।
              আপনি এই লুপ স্টেটমেন্ট ব্যবহার করে ইটারেট করতে পারেন যেকোন ইটারেবল ডেটা স্ট্রাকচারে, যেমন লিস্ট, সেট, ম্যাপ, স্ট্রিং, এবং অন্যান্য।
              '''),
  DartBook(
      title: 'ওয়াইল লুপ (While Loop)',
      description:
          '''ওয়াইল লুপ (While Loop) ডার্ট প্রোগ্রামিং ভাষায় একটি লুপ স্টেটমেন্ট, যার মাধ্যমে একটি নির্দিষ্ট শর্ত সত্য হলে একটি কোড ব্লক বা স্টেটমেন্ট চালানো যায়। ওয়াইল লুপের প্রথমে শর্ত পরীক্ষা করা হয়, এবং যদি শর্ত সত্য হয়, তাহলে লুপের কোড ব্লক চলে যায়। লুপের প্রতিইটারেশনে আবার শর্ত পরীক্ষা করা হয়, এবং যদি শর্ত মিথ্যা হয়, তবে লুপ থেমে যায়।
              সিনট্যাক্স:
              while (condition) { // লুপের কোড ব্লক } 

              condition: লুপের কোড ব্লক চালানোর আগে প্রতি লুপে এই শর্ত পরীক্ষা করা হয়। যদি শর্ত সত্য হয়, তাহলে লুপ চলবে; শর্ত মিথ্যা হলে লুপ থেমে যায়।
              উদাহরণ দেখা যাক:
              void main() { 
                int count = 1; 
                while (count <= 5) { 
                  print("সংখ্যা: $count"); 
                  count++; 
                } 
              } 

              উপরের উদাহরণে, আমরা একটি count ভেরিয়েবল ডিফাইন করেছি এবং এর মান 1 দেওয়া হয়েছে। তারপর, আমরা while লুপ ব্যবহার করেছি যাতে প্রতি ইটারেশনে আমরা সংখ্যা গুলি প্রিন্ট করতে পারি।
              প্রতি ইটারেশনে, লুপের কোড ব্লকে count এর মান প্রিন্ট হয় এবং তারপর count এর মান বাড়ায় এবং শর্ত count <= 5 পরীক্ষা করে যেতে থাকে। লুপ চলতে থাকে যতক্ষণ না count 5 এর সমান বা ছোট হয়ে যায়।
              এই উদাহরণে, আমরা while লুপ ব্যবহার করে একই কাজটি পুনরায় পুনরায় করতে সক্ষম হয়েছি এবং এটি শর্ত সত্য হওয়া পর্যন্ত চলে।
              '''),
  DartBook(
      title: 'ডু-ওয়াইল লুপ (Do-While Loop)',
      description:
          '''ডু-ওয়াইল লুপ (Do-While Loop) ডার্ট প্রোগ্রামিং ভাষায় একটি লুপ স্টেটমেন্ট, যার মাধ্যমে একটি কোড ব্লক বা স্টেটমেন্ট প্রথমে চালানো এবং তারপর একটি নির্দিষ্ট শর্ত সত্য হলে পুনরায় চালানো হয়। ডু-ওয়াইল লুপের বৈশিষ্ট্য হলো প্রথম লুপের পরে শর্তের পরীক্ষা করা হয় এবং লুপ প্রথম বারে একটি বার্তা প্রিন্ট করে এবং শর্ত প্রতি লুপে পরেটের প্রতিটি ইটারেশনে পুনরায় পুনরায় চালাতে সাহায্য করে।
              সিনট্যাক্স:
              do { // লুপের কোড ব্লক } 
              while (condition); 

              condition: লুপের প্রতিটি ইটারেশনে পরেটের শর্ত পরীক্ষা করা হয়। যদি শর্ত সত্য হয়, তবে লুপ চলবে; শর্ত মিথ্যা হলে লুপ বন্ধ হয়।
              উদাহরণ দেখা যাক:
              void main() { 
                int count = 1; 
                do { 
                  print("সংখ্যা: $count"); 
                  count++; 
                } 
                while (count <= 5); 
              } 

              উপরের উদাহরণে, আমরা count নামে একটি ভেরিয়েবল ডিফাইন করেছি এবং এর মান 1 দেওয়া হয়েছে। তারপর, আমরা do-while লুপ ব্যবহার করেছি যাতে প্রথম লুপে একটি বার্তা প্রিন্ট করতে পারি এবং তারপর count 5 এর সমান বা বড় হয়ে তল্লান করা হয়।
              প্রতি ইটারেশনে, প্রথমে লুপের কোড ব্লক চলে এবং "সংখ্যা: 1" মেসেজটি প্রিন্ট হয়। এরপর, count এর মান 2 হয় এবং শর্ত count <= 5 সত্য হয়, তাহলে লুপ পুনরায় পুনরায় চালানো হয়। এই উদাহরণে, ডু-ওয়াইল লুপ প্রথম বার সংখ্যা প্রিন্ট করে এবং শর্ত সত্য হওয়া পর্যন্ত পুনরায় চলে, তারপর পরবর্তী ইটারেশন গুলি চালায়।
              '''),
  DartBook(
      title: 'ডার্ট ফাংশন (Dart Functions)',
      description:
          '''ডার্ট ফাংশন (Dart Functions) হলো একটি স্বাধীন কোড ব্লক, যা একাধিক অপারেশন বা টাস্ক সম্পাদন করার জন্য ব্যবহৃত হয়। ফাংশন একটি নাম আছে এবং যেই ব্লক কোড আমরা প্রয়োজন তার ভেতর থাকে। ফাংশন ব্যবহার করে আমরা কোড রিপিটেশন এবং কোড মডুলারিটি প্রাপ্ত করতে পারি।
              এখানে একটি মিনিমাম ডার্ট ফাংশনের উদাহরণ দেখা যাক:
              void printMessage() { 
                print("এটি একটি উদাহরণ ফাংশন!"); 
              } 
              void main() { 
                printMessage(); // ফাংশন কল করা 
              } 

              উপরের উদাহরণে, printMessage ফাংশন একটি সাধারণ ফাংশন যা কেবলমাত্র "এটি একটি উদাহরণ ফাংশন!" এই ম্যাসেজ প্রিন্ট করে। main ফাংশনে আমরা ফাংশনটি কল করছি যার ফলে উক্ত ম্যাসেজ প্রিন্ট হবে।
              ফাংশন ডিফাইন করার সময় আমরা ফাংশনের মাধ্যমে প্যারামিটার পাস করতে পারি, যার মাধ্যমে আমরা ফাংশনের ভেতর ডেটা পাস করতে পারি। একটি উদাহরণ দেখা যাক:
              void greetUser(String name) { 
                print("হ্যালো, $name!"); 
              } 
              void main() { 
                greetUser("আমিন"); // ফাংশনে প্যারামিটার পাস করা 
              } 

              উপরের উদাহরণে, greetUser ফাংশনটি একটি প্যারামিটার গ্রহণ করে (name) এবং সে প্যারামিটার ব্যবহার করে ম্যাসেজ তৈরি করে। এই ফাংশনটি main ফাংশনে আমরা কল করছি এবং প্যারামিটার হিসেবে "আমিন" পাস করছি, যা ফলে ম্যাসেজ "হ্যালো, আমিন!" প্রিন্ট হবে।
              ফাংশন সম্পর্কিত আরও কয়েকটি বিষয় আছে যেগুলো শেখা গুরুত্বপূর্ণ। ফাংশনের ফর্ম্যাল প্যারামিটার ও আর্গুমেন্ট, ফাংশনের রিটার্ন টাইপ, অ্যারো ফাংশন (Arrow Functions), ফাংশনের নেস্টিং (এক ফাংশনের ভেতর অন্য ফাংশন ডিফাইন করা) ইত্যাদি। প্রথমে আপনি এই মৌলিক সংস্থানগুলি বুঝার চেষ্টা করতে পারেন এবং পরবর্তীতে ডার্ট ফাংশনের বিস্তারিত বৈশিষ্ট্যগুলি শেখা সম্ভব হবে।

              Anonymous Function
              Dart একটি ফাংশনকে এননিমাস ফাংশন হিসেবে ডিফাইন করতে সম্ভব। এননিমাস ফাংশন হলো যে ফাংশন যা নাম দেওয়া হয়না, অর্থাৎ এটির কোনো নাম নেই। এটি মৌলিকভাবে () ব্র্যাকেট দিয়ে ডিফাইন করা হয়।
              এখানে একটি এননিমাস ফাংশনের উদাহরণ দেওয়া হলো:
              void main() { // এননিমাস ফাংশন ডিফাইন করা 
                var add = (int a, int b) { 
                  return a + b; 
                }; // এননিমাস ফাংশন কল করা 
                var result = add(5, 3); 
                print(result); // আউটপুট: 8 
              } 

              উপরের কোডে, add একটি এননিমাস ফাংশন ডিফাইন করেছে যা দুটি সংখ্যা যোগ করে একটি সংখ্যা ফেরত দেয়। তারপরে, এই ফাংশনটি কল করে সংখ্যা 5 এবং 3 যোগ করে 8 ফেরত দেয়।
              এই এননিমাস ফাংশনটির সৌন্দর্য হলো আপনি যখন প্রয়োজন হয়, তখন সরাসরি কোথাও ব্যবহার করতে পারেন, অথবা এটি আনন্দভরে একটি ভ্যারিয়েবলে সংরক্ষণ করতে পারেন।

              Main() function
              শুরুতেই, main() ফাংশন ডার্ট প্রোগ্রামের একটি গুরুত্বপূর্ণ অংশ, যা একটি স্পেশাল ফাংশন হয়ে থাকে এবং যা প্রোগ্রামের প্রধান নিয়ন্ত্রণ প্রাপ্ত করে। ডার্ট প্রোগ্রামের চালনার সময়, সিস্টেম প্রথমে main() ফাংশন কে কল করে শুরু করে এবং প্রোগ্রামের নিষ্ক্রিয় বা প্রধান কোড এখান থেকে চালু হয়।
              এটির সাধারণ সিনট্যাক্স এইভাবে দেখানো যায়:
              void main() { // আপনার প্রোগ্রামের প্রধান কোড এখানে থাকবে } 
              এই main() ফাংশনের কাজ হলো প্রোগ্রামের প্রধান নিয়ন্ত্রণ থেকে সব কিছু চালানো। যে কোন ডার্ট প্রোগ্রামে এই ফাংশন থাকা আবশ্যক এবং এটি প্রোগ্রামের আরম্ভিক পয়েন্ট হিসেবে কাজ করে।
              আপনি এই main() ফাংশনে যা চান, তা ডিফাইন করতে পারেন, এবং প্রোগ্রামের শুরুতে যা করতে চান, সেটি এই ফাংশনে লেখা হয়। এর মাধ্যমে প্রোগ্রাম চালানোর শুরুতে প্রয়োজনীয় কাজগুলি করা হয়, সম্প্রতির প্রয়োজনীয় বিন্দুগুলি তৈরি করা হয় এবং প্রোগ্রামের মুখ্য প্রয়োজনীয় ব্যবস্থা যে কোন ধরনের নিয়ন্ত্রণ এবং নেভিগেশন সরবরাহ করে।
              '''),
  DartBook(
      title: 'ডার্ট রিকারশন (Dart Recursion)',
      description:
          '''ডার্ট রিকারশন (Dart Recursion)  রিকারশন হলো এমন একটি প্রোগ্রামিং কনসেপ্ট যেখানে একটি ফাংশন নিজেকে কল করে নিজের মধ্যে পুনরাবৃত্তি করে। অর্থাৎ, একটি ফাংশন যতবার প্রয়োজন ততবার নিজেকে কল করতে থাকতে পারে।
              রিকারশন একটি সমস্যার সমাধান প্রদান করার একটি সুন্দর উপায় হতে পারে, যখন সমস্যাটি ছোট একটি সমস্যার সাথে সম্পর্কিত আরও একটি ছোট সমস্যা থাকে। এই ছোট সমস্যাগুলি পরস্পর কে আমাদের সমস্যার সমাধান করতে সাহায্য করে।
              এখানে একটি উদাহরণ দেওয়া হল:
              int factorial(int n) {
                if (n == 0 || n == 1) { 
                  return 1; 
              } 
              else { 
                return n * factorial(n - 1); 
              } 
              } 
              void main() { 
                int num = 5; 
                int result = factorial(num); 
                print("Factorial of $num is $result"); 
              } 

              উপরের কোডে, factorial নামের একটি ফাংশন রিকারশন দ্বারা ফ্যাক্টোরিয়াল গণনা করে। ফ্যাক্টোরিয়াল হলো n এর জন্য n থেকে ১ পর্যন্ত সংখ্যাগুলির গুণনফল।
              ফাংশনের মধ্যে, প্রথমে আমরা বের করি যে যদি n এর মান ০ বা ১ হয়, তাহলে ফ্যাক্টোরিয়াল হবে ১। আর যদি n এর মান বেশি হয়, তাহলে আমরা n এর সাথে n-1 এর ফ্যাক্টোরিয়ালের গুণনফল করে ফ্যাক্টোরিয়াল বের করে থাকি।
              main() ফাংশনে আমরা এই factorial ফাংশন কল করে দেখাচ্ছি যে কোনও সংখ্যার ফ্যাক্টোরিয়াল বের করতে পারি।
              এটি রিকারশনের একটি উদাহরণ যেখানে একটি ফাংশন নিজেকে নিজের মধ্যে কল করে নিজের সমস্যার সমাধান করতে ব্যবহার করা হয়।
              '''),
  DartBook(
      title: 'অবজেক্ট-অরিয়েন্টেড প্রোগ্রামিং (OOP)',
      description:
          '''অবজেক্ট-অরিয়েন্টেড প্রোগ্রামিং (OOP) হলো একটি প্রোগ্রামিং প্যারাডাইম যেখানে সব ডেটা এবং কোড অবজেক্টের মধ্যে গ্রুপ করা হয়। এই কনসেপ্টগুলি প্রোগ্রামিং মডুলারিটি বৃদ্ধি করে এবং পুনরাবৃত্তি এবং কোড রিইউজেবিলিটি সুবিধা দেয়।
              আসুন একটি উদাহরণ দিয়ে এই কনসেপ্টগুলি বুঝে নেই:
              class Person { 
                String name; 
                int age; 
                Person(this.name, this.age); 
                void sayHello() { 
                  print("Hello, my name is $name and I am $age years old."); 
                } 
              } 
              void main() { 
                var person1 = Person("Alice", 25); 
                var person2 = Person("Bob", 30); 
                person1.sayHello(); person2.sayHello(); 
              } 

              উপরের কোডে, আমরা Person নামক একটি ক্লাস ডিফাইন করেছি। এই ক্লাসে name এবং age নামে দুটি প্রোপার্টি আছে, এবং sayHello() নামে একটি মেথড আছে।
              ক্লাসটির মধ্যে constructor ব্যবহার করে আমরা অবজেক্ট তৈরি করার সময় ডেটা পাস করতে পারি।
              sayHello() মেথডটি প্রতিটি পার্সন অবজেক্ট জন্য সহজে কথা বলার কাজ করে।
              main() ফাংশনে আমরা দুটি Person অবজেক্ট তৈরি করেছি এবং তাদের জন্য sayHello() মেথড কল করেছি।
              এই উদাহরণে, আমরা অবজেক্ট-অরিয়েন্টেড প্রোগ্রামিং প্যারাডাইমের উপায়ে ডেটা এবং লজিক গ্রুপ করে এবং একটি একক ক্লাস তৈরি করেছি যা মেথড এবং প্রোপার্টিগুলি একত্রিত রাখে।

              Dart প্রোগ্রামিং ভাষায় অবজেক্ট-ওরিয়েন্টেড কনসেপ্টগুলির ব্যাখ্যা দেব।

              1. ক্লাস (Class): ডার্টে, ক্লাস হলো একটি ব্লুপ্রিন্ট বা টেমপ্লেট যা অবজেক্ট তৈরি করার জন্য ব্যবহৃত হয়। একটি ক্লাসে আপনি বৈশিষ্ট্য (properties) এবং মেথড (methods) ডিফাইন করতে পারেন।
              উদাহরণস্বরূপ, একটি Person ক্লাস তৈরি করতে পারেন:
              class Person { 
                String name; 
                int age; 
                void sayHello() { 
                  print('Hello, my name is $name, and I am $age years old.'); 
                } 
              } 

              2. অবজেক্ট (Object): অবজেক্ট হলো ক্লাসের একটি ইনস্ট্যান্স, অর্থাৎ, ক্লাসের ব্লুপ্রিন্ট অনুসরণ করে তৈরি হওয়া একটি অদ্ভুত বস্তু।
              var person1 = Person(); 
              person1.name = 'John'; 
              person1.age = 30; 
              person1.sayHello(); // আউটপুট: "Hello, my name is John, and I am 30 years old." 

              3. ইনহেরিটেন্স (Inheritance): ইনহেরিটেন্স হলো একটি ক্লাসের বৈশিষ্ট্য এবং মেথড অন্য একটি ক্লাসে ইউজ করার সম্ভাবনা। এটি কোড পুনর্বাদ এবং পুনর্বাদ ব্যবহারের একটি উপায় সরবরাহ করে এবং কোড রিউজাবিলিটি বাড়াতে সাহায্য করে।
              class Student extends Person { 
                String school; 
                void study() {
                  print('$name is studying at $school.'); 
                } 
              } 

              4. পলিমর্ফিজম (Polymorphism): পলিমর্ফিজম হলো একটি মেথড যা একের অধিক রূপে কাজ করতে পারে। ইনহেরিটেন্স দ্বারা এটি সম্ভব হয়, এবং এটি প্রোগ্রামিং কোডের উপর ব্যাপক দ্বারা ব্যবহৃত হয়।
              void describe(Person person) { 
                person.sayHello(); 
              } 
              var person = Person(); 
              var student = Student(); 
              describe(person); // সঠিক বাক্য প্রিন্ট করবে 
              describe(student); // সঠিক বাক্য প্রিন্ট করবে 

              5. কাপসুলেশন (Encapsulation): কাপসুলেশন হলো একটি ক্লাসের বৈশিষ্ট্য এবং মেথডের সীমা দ্বারা আদর্শ বা নির্দিষ্ট ভাবে গোপন করা। এটি ডেটা অবজেক্টের স্থায়ীতা এবং কোড সুরক্ষা বাড়াতে সাহায্য করে।
              class BankAccount { 
                double _balance = 0; 
                void deposit(double amount) {
                  if (amount > 0) { 
                  _balance += amount; 
                } 
              } 
                double getBalance() { 
                  return _balance; 
                } 
              } 

              6. অব্জেক্ট-ওরিয়েন্টেড প্রোগ্রামিং (OOP): অব্জেক্ট-ওরিয়েন্টেড প্রোগ্রামিং একটি প্রোগ্রামিং প্যারাডাইম যেখানে ডেটা এবং ফাংশনগুলি একটি অবজেক্টের মধ্যে গোপন থাকে এবং এই অবজেক্টের সাথে সম্পর্কিত অপারেশনগুলি কাজ করে।
              এই মৌলিক অবজেক্ট-অরিয়েন্টেড কনসেপ্টগুলি ডার্ট প্রোগ্রামিং ভাষায় ব্যবহার করা হয় যাতে কোড সহজে বুঝতে এবং পরিচালনা করতে সম্পর্কিত ডেটা এবং লজিকের মধ্যে সম্পর্ক দেওয়া যায়।
              '''),
  DartBook(
      title: 'ক্লাস (Class)',
      description:
          '''ক্লাস হলো একটি টেমপ্লেট বা ব্লুপ্রিন্ট যা অবজেক্ট তৈরির জন্য ব্যবহার হয়। এটি ডার্ট প্রোগ্রামে নতুন ডেটা টাইপ তৈরি করে এবং একটি সেট বা গ্রুপ সংক্রান্ত মেথডগুলির সাথে থাকতে পারে। এটি অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং (OOP) এর একটি মৌলিক অংশ।
              একটি সাধারণ ক্লাস ডিফাইন করার সিনট্যাক্স হল:
              class ClassName { // ক্লাসের বৈশিষ্ট্য (ভেরিয়েবল) গুলি 
              DataType propertyName; // ক্লাসের মেথড গুলি 
              ReturnType methodName() { // মেথডের কোড } } 
              এই উদাহরণে, এই ক্লাস ডিফাইনিশনে আপনি ClassName এবং এটির ভিতরে থাকা বৈশিষ্ট্য (প্রোপার্টিজ) এবং মেথডগুলি ডিফাইন করতে পারেন। বৈশিষ্ট্যের ডেটা টাইপ এবং মেথডের রিটার্ন টাইপ সম্পর্কে পরিস্থিতি অনুযায়ী সংজ্ঞায়িত করতে হবে।এই ক্লাসে আমরা একটি বৈশিষ্ট্য এবং একটি মেথড ডিফাইন করেছি।

              ক্লাসের বৈশিষ্ট্য (Properties):
              ক্লাসে বৈশিষ্ট্য (properties) হলো ডেটা মেম্বার যা ক্লাসের ইনস্ট্যান্সের জন্য ডেটা স্টোর করে। এই বৈশিষ্ট্যগুলি ক্লাসের ইনস্ট্যান্সের সাথে সংক্রান্ত থাকে।
              class Person { String name; // একটি বৈশিষ্ট্য (property) } 

              ক্লাসের মেথড (Methods):
              ক্লাসে মেথড হলো ক্লাসের ইনস্ট্যান্সের জন্য কোড এবং ফাংশনালিটি ডিফাইন করে তা ক্লাসের ইনস্ট্যান্স সাথে সংক্রান্ত করা।
              class Person { 
                String name; void introduce() { 
                  print('Hello, my name is $name.'); 
                } 
              } 

              ক্লাসের অবজেক্ট (Objects of a Class):
              ক্লাস তৈরি হলে, আপনি একে বা একাধিক অবজেক্ট তৈরি করতে পারেন। অবজেক্ট হলো ক্লাসের ইনস্ট্যান্স এবং ক্লাসের বৈশিষ্ট্য এবং মেথড গুলি ব্যবহার করতে পারে।
              void main() { // ক্লাসের অবজেক্ট তৈরি 
                Person person1 = Person(); // অবজেক্টের বৈশিষ্ট্য সেট করা 
                person1.name = 'John'; // অবজেক্টের মেথড কল করা 
                person1.introduce(); // আউটপুট: "Hello, my name is John." 
              } 

              উপরের উদাহরণে, আমরা Person ক্লাসের অবজেক্ট person1 তৈরি করে তার বৈশিষ্ট্য সেট করে এবং তার মেথড introduce() কল করেছি।
              এই ভাবে, ডার্ট এ ক্লাস এবং অবজেক্ট ব্যবহার করে ওপর করে প্রোগ্রাম লেখা হয়। এটি অবজেক্ট-ওরিয়েন্টেড প্রোগ্রামিং প্যারাডাইমের একটি মৌলিক অংশ।

              অবজেক্ট নির্মাণ (Creating Objects):
              অবজেক্ট হলো ক্লাসের একটি ইনস্ট্যান্স, অর্থাৎ, ক্লাসের ব্লুপ্রিন্ট অনুসরণ করে তৈরি হওয়া একটি বস্তু। আপনি ক্লাস ডিফাইন করার পর অবজেক্ট তৈরি করতে পারেন এবং তারপর সেই অবজেক্টের বৈশিষ্ট্য এবং মেথড ব্যবহার করতে পারেন।
              এই উদাহরণে, আমরা Person ক্লাস থেকে একটি অবজেক্ট তৈরি করব:
              class Person { 
                String name; 
                int age; 
              } 

              void main() { // অবজেক্ট তৈরি 
                var person1 = Person(); // অবজেক্টে ডেটা সেট করা 
                person1.name = 'John'; 
                person1.age = 30; // অবজেক্টের ডেটা দেখা 
                print('Name: ${person1.name}, 
                Age: ${person1.age}'); 
              } 

              অবজেক্ট ব্যবহার (Using Objects):
              অবজেক্ট তৈরি করার পর, আপনি অবজেক্টের বৈশিষ্ট্য এবং মেথডগুলি ব্যবহার করতে পারেন। নিম্নলিখিত উদাহরণে, আমরা Person অবজেক্টের বৈশিষ্ট্য এবং মেথড ব্যবহার করছি:
              class Person { 
                String name; 
                int age; 
                void introduce() { 
                  print('Hello, my name is $name, and I am $age years old.'); 
                } 
              } 
              void main() { 
                var person1 = Person(); 
                person1.name = 'John'; 
                person1.age = 30; // অবজেক্টের মেথড কল করা 
                person1.introduce(); // আউটপুট: "Hello, my name is John, and I am 30 years old." 
              } 

              উপরে, আমরা Person অবজেক্ট person1 তৈরি করে তার নাম এবং বয়স সেট করেছি এবং তারপর introduce() মেথড কল করে অবজেক্টের ডেটা দেখলাম।
              অবজেক্ট নির্মাণ এবং ব্যবহার ডার্ট প্রোগ্রামিং ভাষায় অত্যন্ত গুরুত্বপূর্ণ ধাপ, যা ডেটা এবং লজিক স্ট্রাকচার পরিচালনার জন্য ব্যবহৃত হয়।
              ডার্ট প্রোগ্রামিং ভাষায় কনস্ট্রাক্টর (Constructor) হলো একটি মেথড যা একটি ক্লাসের অবজেক্ট তৈরি করতে ব্যবহৃত হয়। কনস্ট্রাক্টরগুলি অবজেক্ট তৈরির সময় স্বয়ংক্রিয়ভাবে কাজ করে এবং অবজেক্টের আদর্শের নির্দিষ্ট দ্রব্যাদি সেট আপ করতে সাহায্য করে।
              একটি ক্লাসে একটি ডিফল্ট কনস্ট্রাক্টর থাকে, যা স্বয়ংক্রিয়ভাবে ক্লাসের অবজেক্ট তৈরি করে। তবে, আপনি ক্লাসে আপনার নিজস্ব কাস্টম কনস্ট্রাক্টর ডিফাইন করতে পারেন যেটি আপনার প্রয়োজনীয় প্যারামিটার সেট আপ করে অবজেক্ট তৈরি করতে সাহায্য করে।
              একটি কনস্ট্রাক্টর ডিফাইন করার সূত্র নিম্নলিখিত:
              ClassName(parameters) { // কনস্ট্রাক্টরের কোড } 
              এখানে, ClassName হলো ক্লাসের নাম এবং parameters হলো কনস্ট্রাক্টরের প্যারামিটার লিস্ট।
              একটি উদাহরণ দেওয়া হল:
              class Person { 
                String name; 
                int age; // কাস্টম কনস্ট্রাক্টর 
                Person(String name, int age) { 
                  this.name = name; 
                  this.age = age; 
                } 
                void introduce() { 
                  print('Hello, my name is $name, and I am $age years old.'); 
                } 
              } 
              void main() { // কনস্ট্রাক্টর ব্যবহার করে অবজেক্ট তৈরি 
                var person1 = Person('John', 30); 
                person1.introduce(); // আউটপুট: "Hello, my name is John, and I am 30 years old." 
              } 

              উপরে, আমরা Person ক্লাসের কাস্টম কনস্ট্রাক্টর ডিফাইন করেছি যেখানে আমরা প্যারামিটার হিসেবে name এবং age নেয়া হয়েছে। প্যারামিটারের মাধ্যমে অবজেক্টের বৈশিষ্ট্য সেট করা হয়েছে।

              "this" একটি কীওয়ার্ড যা Dart প্রোগ্রামিং ভাষায় ব্যবহৃত হয় এবং এটি সাধারণভাবে ক্লাসের মেথডে অথবা বৈশিষ্ট্যের ভিতরে আপনার ক্লাসের বৈশিষ্ট্যের সাথে সম্পর্কিত নোটেশন দেয়। এটি একটি ইনস্ট্যান্স অবজেক্টের বৈশিষ্ট্যের সাথে সম্পর্কিত মধ্যবর্তী নোটেশন দেয় এবং অবজেক্ট এবং ক্লাসের বৈশিষ্ট্যের মধ্যে সংঘটিত কোনও ভুল বা স্পষ্টতা সংঘটিত না হয়, সেই সমস্যাটি সমাধান করার জন্য "this" ব্যবহার করা হয়।
              "this" কীওয়ার্ডের মাধ্যমে আপনি একই নামের বৈশিষ্ট্য এবং প্যারামিটারের নাম সম্পর্কে স্পষ্টতা স্থাপন করতে পারেন। এটি ক্লাসের কোড পড়া সময় প্রয়োজনে সাধারণভাবে ব্যবহৃত হয় যাতে অবজেক্টের বৈশিষ্ট্য এবং প্যারামিটারের নাম স্পষ্ট থাকে এবং দ্বিঘাত অর্থাৎ অবজেক্টের বৈশিষ্ট্য এবং বৈশিষ্ট্যের সাথে প্যারামিটারের স্কোপ স্পষ্ট হয়।
              একটি উদাহরণ দেওয়া হল:
              class Person { 
                String name; 
                int age; // কাস্টম কনস্ট্রাক্টর 
                Person(String name, int age) { 
                  this.name = name; // "this" ব্যবহার করে বৈশিষ্ট্যের নাম প্রকাশ করা হয় 
                  this.age = age; 
                } 
                void introduce() { 
                  print('Hello, my name is ${t_h_i_s.name}, and I am ${t_h_i_s.age} years old.'); // "this" ব্যবহার করে বৈশিষ্ট্যের নাম প্রকাশ করা হয় 
                } 
              } 

              void main() { // কনস্ট্রাক্টর ব্যবহার করে অবজেক্ট তৈরি 
                var person1 = Person('John', 30); 
                person1.introduce(); // আউটপুট: "Hello, my name is John, and I am 30 years old." 
              } 
              "this" কীওয়ার্ড ব্যবহার করে আমরা প্রতিটি অবজেক্টের বৈশিষ্ট্যের নামের সাথে প্রতিটি প্যারামিটারের নাম স্পষ্টভাবে স্থাপন করেছি, যাতে বৈশিষ্ট্য এবং প্যারামিটারের নামের সাথে কোন সমস্যা না হয়। "this" কীওয়ার্ড ব্যবহার করে কোডে প্রদান করা হয় যে "name" এবং "age" বৈশিষ্ট্যগুলি ক্লাসের বৈশিষ্ট্যের মূল্যের সাথে মিলে। এই কোডে, "this" কীওয়ার্ড ব্যবহার করা হচ্ছে যাতে কোড প্রদান করা যেতে সেই বৈশিষ্ট্যের মূল্য সেট হয়, যা ক্লাসের বৈশিষ্ট্য হতে পারে।
              "this" কীওয়ার্ডের ব্যবহার প্রধানভাবে একই নামের বৈশিষ্ট্য এবং প্যারামিটারের নামে সংঘটিত হলে সহায়ক হয়, কেননা তার মাধ্যমে ডার্ট কোড কোন বৈশিষ্ট্য বা মেথডের সাথে যে বৈশিষ্ট্য বা মেথডের সাথে সম্পর্কিত তা নির্দেশ করা যেতে সাহায্য করে।

              "static" একটি কীওয়ার্ড যা ডার্ট প্রোগ্রামিং ভাষায় ব্যবহার হয় এবং এটি ক্লাসের একটি বৈশিষ্ট্য বা মেথড স্ট্যাটিক করে তৈরি করে। "static" বৈশিষ্ট্য বা মেথড একটি ক্লাসের অবজেক্ট বা ইনস্ট্যান্সের সাথে সম্পর্কিত নয়, তার পরিবর্তে ক্লাস নিজের সাথে সম্পর্কিত।
              এই কীওয়ার্ড ব্যবহার করা হয়, যখন আপনি একটি বৈশিষ্ট্য বা মেথডকে একটি ক্লাসের সব অবজেক্টের সাথে সাঝা করতে চান না, বরং এটি সেই ক্লাস নিজের জন্য স্থায়ী এবং ক্লাসের ইনস্ট্যান্সের সাথে স্থায়ী থাকতে চান।
              একটি উদাহরণ দেওয়া যাক:
              class Circle { 
                static const double pi = 3.14159; // স্থায়ী সংখ্যা 
                static double calculateArea(double radius) { 
                  return pi * radius * radius; 
                } 
              } 
              void main() { 
                var radius = 5.0; var area = Circle.calculateArea(radius); 
                print('বৃত্তের ক্ষেত্রফল: $area'); print('পাই (π) এর মান: ${Circle.pi}'); 
              } 

              উপরে, "static" কীওয়ার্ড ব্যবহার করে "pi" বৈশিষ্ট্যটি স্থায়ী করা হয়েছে, যা Circle ক্লাসের সব অবজেক্টের সাথে সম্পর্কিত নয়, তার পরিবর্তে এটি ক্লাস নিজের জন্য স্থায়ী থাকতে থাকে। "calculateArea" মেথডটিও স্থায়ী করা হয়েছে এবং এটি ক্লাসের ইনস্ট্যান্সের সাথে সম্পর্কিত নয়, এটি ক্লাস নিজের জন্য স্থায়ী থাকতে থাকে।
              আমরা মুখ্য কোডে "Circle.calculateArea(radius)" ব্যবহার করে "calculateArea" মেথড কল করতে পারি এবং "Circle.pi" ব্যবহার করে "pi" স্থায়ী বৈশিষ্ট্যে অ্যাক্সেস করতে পারি, যেটি ক্লাস নিজের সাথে সম্পর্কিত থাকে।
              '''),
  DartBook(
      title: 'অবজেক্ট (Object)',
      description: '''Lorem Ipsum has been the industrys'''),
  DartBook(
      title: 'ইনহেরিটেন্স (Inheritance)',
      description:
          '''ডার্ট প্রোগ্রামিং ভাষায়, "Inheritance" হলো একটি প্রধান অবজেক্ট-অরিয়েন্টেড প্রোগ্রামিং কনসেপ্ট যাতে একটি ক্লাস একটি অন্য ক্লাসের বৈশিষ্ট্য এবং মেথড পুনর্বিবেচিত করতে পারে। এটি একটি বৈশিষ্ট্যও একটি অবজেক্ট স্থানান্তর করতে সাহায্য করে, যেখানে নতুন ক্লাস আপনার ইতিহাস ক্লাসের বৈশিষ্ট্য এবং মেথড অনুসরণ করে এবং তাদের সাথে নতুন কোড বা মেথড যুক্ত করতে সহায্য করে।
              ক্লাস ইনহেরিটেন্সের স্যাকল:
              class Parent { 
                void display() { 
                  print('This is the Parent class.'); 
                } 
              }

              class Child extends Parent { // Child ক্লাস প্যারেন্ট ক্লাস থেকে বৈশিষ্ট্য এবং মেথড পুনর্বিবেচিত করছে 
                void show() { 
                  print('This is the Child class.'); 
                } 
              } 

              void main() { 
                Child child = Child(); child.display(); // প্যারেন্ট ক্লাসের মেথড ব্যবহার child.show(); // চাইল্ড ক্লাসের মেথড ব্যবহার 
              } 
              উপরের উদাহরণে, আমরা "Parent" ক্লাস ডিফাইন করেছি যাতে একটি "display()" মেথড আছে। তারপর, "Child" ক্লাস ডিফাইন করেছি যেখানে "Parent" ক্লাস থেকে বৈশিষ্ট্য এবং মেথড পুনর্বিবেচিত করা হয়েছে এবং তাদের সাথে "show()" নামে আরেকটি মেথড যুক্ত করা হয়েছে। "Child" ক্লাস প্যারেন্ট ক্লাসের বৈশিষ্ট্য এবং মেথড ব্যবহার করতে পারে এবং নতুন বৈশিষ্ট্য বা মেথড যুক্ত করতে পারে।

              কনস্ট্রাক্টর ইনহেরিটেন্স:
              কনস্ট্রাক্টরগুলি ওয়েল ডিফল্ট কনস্ট্রাক্টরে ইনহেরিট করতে পারে। কনস্ট্রাক্টর ইনহেরিটেন্সের ক্ষেত্রে, যদি কোন কনস্ট্রাক্টর না থাকে তবে অটোম্যাটিকভাবে সুপার ক্লাসের ডিফল্ট কনস্ট্রাক্টর কল হয়।
              class Parent { 
                String name; 
                Parent(this.name); 
              } 
              class Child extends Parent { 
                int age; 
                Child(String name, this.age) : super(name); // সুপার ক্লাসের কনস্ট্রাক্টর কল করা হচ্ছে 
              } 
              void main() { 
                Child child = Child('Alice', 5); 
                print('Name: ${child.name}, 
                Age: ${child.age}'); 
              } 

              উপরের উদাহরণে, "Parent" ক্লাসে একটি কনস্ট্রাক্টর আছে যা একটি নাম প্যারামিটার প্রদান করে। "Child" ক্লাসে একটি কনস

              Inheritance (ইনহেরিট্যান্স) ডার্ট প্রোগ্রামিং ভাষায় একটি প্রোগ্রামিং প্রিন্সিপল যা একটি ক্লাস অথবা অবজেক্ট একটি অন্য ক্লাসের বৈশিষ্ট্য এবং মেথড ব্যবহার করতে সাহায্য করে। ইনহেরিট্যান্সে দুটি প্রধান ক্লাস থাকে - সুপার ক্লাস (Superclass) এবং সাব ক্লাস (Subclass), যেখানে সুপার ক্লাস হলো উপরের বা প্যারেন্ট ক্লাস এবং সাব ক্লাস হলো নিচের বা চাইল্ড ক্লাস। সাব ক্লাস সুপার ক্লাসের সমস্ত বৈশিষ্ট্য এবং মেথড কাস্টমাইজ করতে পারে এবং অতিরিক্ত বৈশিষ্ট্য এবং মেথড যোগ করতে পারে।
              সুপার ক্লাস (Superclass) এবং সাব ক্লাস (Subclass):
              সুপার ক্লাস হলো সেই ক্লাস যার বৈশিষ্ট্য এবং মেথড সাব ক্লাস গুলি ইনহেরিট করে, অর্থাৎ সেই ক্লাস যা নতুন ক্লাসের বেসিস হয়। সাব ক্লাস হলো সেই ক্লাস যা সুপার ক্লাসের বৈশিষ্ট্য এবং মেথড ইনহেরিট করে এবং নতুন বৈশিষ্ট্য এবং মেথড যোগ করতে পারে।
              সুপার ক্লাসের সুপারক্লাস (Superclass's superclass):
              সুপার ক্লাস সম্পর্কে আরও জানতে, সুপার ক্লাসের সুপারক্লাস বা প্যারেন্ট ক্লাস ইতিহাসে আরও একটি সুপার ক্লাসের সাথে সংযুক্ত হতে পারে।
              সাব ক্লাসের সাবক্লাস (Subclass's subclass):
              সাব ক্লাসের সাবক্লাস বা চাইল্ডের চাইল্ড ক্লাস হতে পারে, এবং এটি সাব ক্লাসের সুপার ক্লাস এবং সাব ক্লাসের সুপারক্লাসের সাথে সংযোগ থাকতে পারে।
              ডার্টে ইনহেরিটেন্স:
              ডার্টে ইনহেরিটেন্স সাধারণীকরণে ডিফাইন করা হয়। একটি ক্লাস একটি অবজেক্ট অরিয়েন্টেড ভাষা ক্লাস থেকে ইনহেরিট করতে পারে, এবং ইনহেরিট করা ক্লাসের মধ্যে সুপার ক্লাসের বৈশিষ্ট্য এবং মেথড অ্যাক্সেস করতে পারে।
              একটি সুপার ক্লাস ডিফাইন করার সুত্র:
              class Superclass { // সুপার ক্লাসের বৈশিষ্ট্য এবং মেথড ডিফাইন করুন } 
              এবং একটি সাব ক্লাস তৈরি করার সুত্র:
              class Subclass extends Superclass { // সাব ক্লাসের বৈশিষ্ট্য এবং মেথড ডিফাইন করুন } 
              উদাহরণ:
              // একটি মানব (Person) ক্লাস ডিফাইন করা হলো 
              class Person { 
                String name; 
                int age; 
                Person(this.name, this.age); 
                void introduce() { 
                  print('Hello, my name is $name, and I am $age years old.'); 
                } 
              } // "Student" ক্লাস একটি "Person" ক্লাস থেকে উত্তরাধিকার নেয় 

              class Student extends Person { 
                String school; Student(String name, int age, this.school) : super(name, age); void study() { 
                  print('$name is studying at $school.'); 
                } 
              } 

              void main() { 
                var student = Student('John', 20, 'XYZ School'); 
                student.introduce(); // প্যারেন্ট ক্লাসের মেথড কল করা হয় 
                student.study(); // উত্তরাধিকারিত ক্লাসের মেথড কল করা হয় 
              } 
              
              উপরে, আমরা "Person" ক্লাস তৈরি করেছি, এবং "Student" ক্লাস তৈরি করেছি যা "Person" ক্লাসের উত্তরাধিকার নেয়। "Student" ক্লাস তৈরির সময় "super" কীওয়ার্ড ব্যবহার করে "Person" ক্লাসের কনস্ট্রাক্টর কল করা হয়, যাতে "Student" ক্লাসের বৈশিষ্ট্য "name" এবং "age" সেট হতে পারে। "Student" ক্লাসে আরও একটি বৈশিষ্ট্য "school" যোগ করা হয় এবং নতুন একটি মেথড "study" ডিফাইন করা হয়।
              মূল ক্লাসের বৈশিষ্ট্য এবং মেথড উত্তরাধিকার নেওয়া ক্লাসে ব্যবহার করা যেতে এবং তাদের উদ্দেশ্যমাত্র "super" কীওয়ার্ড দ্বারা কোডে নির্দেশ দেওয়া হয়।
              মূল বিষয় হলো, ইনহেরিট্যান্সের মাধ্যমে আপনি একটি নতুন ক্লাস তৈরি করতে পারেন, যা একটি বা একাধিক সুপার ক্লাসের বৈশিষ্ট্য এবং মেথড ব্যবহার করে তাদের সাথে সম্পর্কিত থাকে। এটি প্রোগ্রাম কোডে মোডুল্যারিটি এবং পুনর্বয়বহারশীলতা বাড়াতে সাহায্য করে, যার ফলে কোড স্বাভাবিকভাবে বৃদ্ধি পায়।

              সুপার কনস্ট্রাক্টর ডার্ট প্রোগ্রামিং ভাষায় উত্তরাধিকার সহ ক্লাসের কনস্ট্রাক্টরের একটি বিশেষ ধরণ যা উত্তরাধিকার গ্রহণ করতে সাহায্য করে। উত্তরাধিকার কনস্ট্রাক্টর একটি সাব ক্লাসের কনস্ট্রাক্টর যেটি প্যারেন্ট ক্লাসের কনস্ট্রাক্টর কল করতে ব্যবহৃত হয়। এটি বৈশিষ্ট্য এবং মেথডগুলির সাথে মিলে আসার সময় আপনি প্যারেন্ট ক্লাসের কনস্ট্রাক্টরের কোড কাজ করাতে সাহায্য পাবেন।
              উদাহরণ:
              class Person { 
                String name; 
                Person(this.name); 
                void introduce() { 
                  print('Hello, my name is $name.'); 
                } 
              } 
              class Student extends Person { 
                String school; 
                Student(String name, this.school) : super(name); // প্যারেন্ট ক্লাসের কনস্ট্রাক্টর কল করা হয় 
                void study() { 
                  print('$name is studying at $school.'); 
                } 
              } 
              void main() { 
                var student = Student('John', 'XYZ School'); 
                student.introduce(); // প্যারেন্ট ক্লাসের মেথড কল করা হয় student.study(); 
              } 
              
              উপরে, "Student" ক্লাসে একটি উত্তরাধিকার কনস্ট্রাক্টর ডিফাইন করা হয় যা "super" কীওয়ার্ড দ্বারা "Person" ক্লাসের কনস্ট্রাক্টরের কোড কল করে। এই উত্তরাধিকার কনস্ট্রাক্টরের মাধ্যমে "Student" ক্লাসের প্যারেন্ট ক্লাসের কনস্ট্রাক্টরের বৈশিষ্ট্য "name" সেট করা হয়।
              "super" কীওয়ার্ড সাধারণভাবে প্যারেন্ট ক্লাসের মধ্যে থাকার প্রথম অবস্থান থেকে কনস্ট্রাক্টরের কোড কল করবে। এই উত্তরাধিকার কনস্ট্রাক্টরটি প্যারেন্ট ক্লাসের কনস্ট্রাক্টরে প্রদানকৃত প্যারামিটারগুলি পাস করতে সাহায্য করে, যা প্যারেন্ট ক্লাসের কনস্ট্রাক্টরে ব্যবহার করা হয়।

              '''),
  DartBook(
      title: 'পলিমর্ফিজম (Polymorphism)',
      description: '''Lorem Ipsum has been the industrys'''),
  DartBook(
      title: 'কাপসুলেশন (Encapsulation)',
      description: '''Lorem Ipsum has been the industrys'''),
  DartBook(
      title: 'এবস্ট্রাক্ট ক্লাস (Abstract Class)',
      description:
          '''ডার্ট প্রোগ্রামিং ভাষায়, "Abstract Class" একটি স্পেশাল ক্লাস যা এমন একটি ক্লাস যা ইন্সট্যান্স তৈরি করা যায় না, এবং এটি একটি ইনটারফেস্ট বা সুপার-ক্লাসের যতগুলি মেথড ডিফাইন করে সেগুলির দরকার হয় বৈশিষ্ট্য। সাধারণভাবে, Abstract Class এবং এই ক্লাসের ইন্সট্যান্স তৈরি করা যায় না, তা বাদ দিয়ে মেথড এবং বৈশিষ্ট্য ডিফাইন করার জন্য ব্যবহৃত হয়।
              একটি Abstract Class তৈরি করার জন্য, আপনি "abstract" কীওয়ার্ড ব্যবহার করে ক্লাস ডিফাইন করেন এবং সেই ক্লাসে Abstract মেথডগুলি ডিফাইন করেন, তাদের বডি দিয়ে কোড বা ইমপ্লিমেন্টেশন না দেওয়া হয়। Abstract মেথড কেবলমাত্র মেথডের স্পেসিফিকেশন দেয়, কোড না। সেটা হলো, এই মেথড অবশ্যই উত্তরাধিকারিত ক্লাসে ইমপ্লিমেন্ট করা হবে, যে ক্লাস এই Abstract Class কে এক্সটেন্ড করতে চায়।
              Abstract Class ডিফাইন করার উদাহরণ:
              abstract class Shape { // Abstract method double area(); } 
              class Circle extends Shape { 
                double radius; Circle(this.radius); // Implementing the abstract method 
                @override double area() { 
                  return 3.14 * radius * radius; 
                } 
              } 
              class Rectangle extends Shape { 
                double width; 
                double height; 
                Rectangle(this.width, this.height); // Implementing the abstract method 
                @override double area() { 
                  return width * height; 
                } 
              } 
              void main() { 
                Circle circle = Circle(5.0); 
                print('Circle Area: ${circle.area()}'); // Output: Circle Area: 78.5 
                Rectangle rectangle = Rectangle(4.0, 6.0); 
                print('Rectangle Area: ${rectangle.area()}'); // Output: Rectangle Area: 24.0 
              } 

              উপরে, "Shape" একটি Abstract Class যা "area" নামে একটি Abstract Method ডিফাইন করে। "Circle" এবং "Rectangle" ক্লাসগুলি "Shape" ক্লাস থেকে এক্সটেন্ড করে এবং "area" মেথড ইমপ্লিমেন্ট করে, অতএব এদের ইন্সট্যান্স তৈরি করতে পারে এবং "area" মেথড কল করতে পারে। "main" ফাংশনে, "Circle" এবং "Rectangle" ক্লাসের ইন্সট্যান্স তৈরি করে "area" মেথড কল করা হয় এবং ডাটার এরিয়া প্রিন্ট করা হয়।
              এর মাধ্যমে Abstract Class আপনাকে একটি কোমন ইন্টারফেস ডিফাইন করার সুযোগ দেয় এবং সেই ইন্টারফেস ইমপ্লিমেন্ট করার দায়িত্ব স্থাপন করে, যাতে সমান মেথড স্যান্ডার্ড এবং বৈশিষ্ট্য স্যান্ডার্ড থাকে।
              '''),
  DartBook(
      title: 'ইন্টারফেস (Interfaces)',
      description:
          '''ইন্টারফেস (Interfaces) ডার্ট প্রোগ্রামিং ভাষায় একটি অংশদান হিসেবে কাজ করে, এবং এটি একটি ক্লাসের প্রত্যেক মেথডের একটি সোনালী সংজ্ঞা সরবরাহ করে, কিন্তু কোনও মেথডের ডিফাইন করা না হয়। ইন্টারফেস একটি অবজেক্ট বা ক্লাসের প্রতিনির্দিষ্ট চাইতে বেশি ক্লাসের একটি সোনালী ব্লুপ্রিন্ট প্রদান করে, যাতে ক্লাসগুলি সেই ইন্টারফেসের মেথডগুলি ইমপ্লিমেন্ট করতে পারে।
              ইন্টারফেস ডিফাইন করার জন্য, আপনি ক্লাস ডিফাইন করার সময় implements কীওয়ার্ড ব্যবহার করতে পারেন, এবং এই ইন্টারফেসের মেথডগুলি সব মেথড ডিফাইন করতে হয়:
              // একটি ইন্টারফেস ডিফাইন করা হয় abstract class Shape { 
                double area(); void draw(); 
              } // Shape ইন্টারফেস ইমপ্লিমেন্ট করা হয় 
              class Circle implements Shape {
                double radius; Circle(this.radius); 
                @override double area() { 
                  return 3.14 * radius * radius; 
                } 
                @override void draw() { 
                  print('Drawing a circle'); 
                } 
              } 
              void main() { 
                Circle circle = Circle(5); 
                print('Area of circle: ${circle.area()}'); 
                circle.draw(); 
              } 

              উপরে, "Shape" ইন্টারফেস ডিফাইন করা হয় এবং এই ইন্টারফেসের মেথডগুলি সব অ্যাবস্ট্র্যাক্ট হয়। "Circle" ক্লাস "Shape" ইন্টারফেস ইমপ্লিমেন্ট করে, এবং সব ইন্টারফেস মেথডগুলি ডিফাইন করে। "main" ফাংশনে, আমরা "Circle" ক্লাসের অবজেক্ট তৈরি করে সেটির কোড আপডেট করতে এবং "area" এবং "draw" মেথডগুলি কল করতে দেখতে পাচ্ছি।
              ইন্টারফেস ব্যবহার করে আপনি একটি ক্লাস তৈরি করতে পারেন যা একাধিক ইন্টারফেস ইমপ্লিমেন্ট করে এবং এই ইন্টারফেসের সব মেথড ইমপ্লিমেন্ট করে। এটি প্রোগ্রামের মডুলারিটি এবং পরিবর্তনশীলতা বাড়াতে সাহায্য করে, কারণ এটি আপনার প্রোগ্রামে পরিবর্তন সহায়ক করতে সাহায্য করে।
              '''),
  DartBook(
      title: 'মেথড (Methods)',
      description:
          '''মেথড (Methods) হলো একটি ফাংশন যা একটি ক্লাসে ডিফাইন করা হয় এবং সেই ক্লাসের অবজেক্টের সাথে সম্পর্কিত কাজ করে। মেথডগুলি ক্লাসের বৈশিষ্ট্য নির্ধারণ করতে ব্যবহৃত হয় এবং সেই ক্লাসের অবজেক্টের সাথে সম্পর্কিত অপারেশনগুলি নির্দেশ করতে সাহায্য করে।
              একটি মেথড ডিফাইন করার সূত্র নিম্নলিখিত:
              returnType methodName(parameters) { // মেথডের কোড } 
              returnType: মেথড থেকে ফিরে আসার মাধ্যমে প্রাপ্ত মৌলিক ডেটা টাইপ নির্দেশ করে, অর্থাৎ মেথড যদি কোন মৌলিক মান (যেমন, int, double, String) রিটার্ন করে তাহলে returnType এই মান হতে হবে। যদি মেথড কোন মৌলিক মান রিটার্ন না করে তাহলে returnType হতে পারে 'void'.
              methodName: মেথডের নাম যা ক্লাসের ব্যবহারকারীরা মেথডটি কল করতে ব্যবহার করতে পারেন।
              parameters: মেথডে প্রয়োজনীয় প্যারামিটারের লিস্ট, যা মেথডের কাজ সম্পাদন করতে সাহায্য করে। এই প্যারামিটার গুলি কোন মৌলিক মানের মধ্যে থাকতে পারে এবং এগুলি প্যারামিটারের নাম এবং তাদের ডেটা টাইপ দ্বারা নির্ধারণ করা হয়।
              একটি উদাহরণ দেওয়া হলো:
              class Calculator { // দুটি সংখ্যার যোগফল নির্দিষ্ট করতে একটি মেথড 
                int add(int a, int b) { 
                return a + b; 
                } // দুটি সংখ্যার বিয়োগফল নির্দিষ্ট করতে একটি মেথড 
                int subtract(int a, int b) { 
                  return a - b; 
                } 
              } 

              void main() { 
                Calculator calculator = Calculator(); 
                int sum = calculator.add(5, 3); 
                print('Sum: $sum'); // আউটপুট: 
                Sum: 8 int difference = calculator.subtract(10, 4); 
                print('Difference: $difference'); // আউটপুট: Difference: 6 
              } 

              উপরে, আমরা "Calculator" ক্লাসে দুটি মেথড "add" এবং "subtract" ডিফাইন করেছি, যা দুটি সংখ্যার যোগফল এবং বিয়োগফল নির্দিষ্ট করে। এই মেথডগুলি মেথড নামের সাথে দুটি প্যারামিটার নেয় এবং যোগফল এবং বিয়োগফল রিটার্ন করে।
              মেথডগুলি ক্লাসের বৈশিষ্ট্য এবং অবজেক্টের সাথে সম্পর্কিত কাজ করে এবং ক্লাসের অবজেক্টের উপর কল করা যেতে পারে।


              মেথড ওভাররাইডিং (Method Overriding) হলো ডার্ট প্রোগ্রামিং ভাষায় একটি প্রোসেস যা একটি ক্লাসের একটি প্যারেন্ট ক্লাসে ডিফাইন করা মেথডটি অবজেক্টের সাথে সম্পর্কিত মেথডের বৈশিষ্ট্য এবং কাজ পুনর্নির্দেশ করে।
              মেথড ওভাররাইড করার জন্য নিম্নলিখিত নিয়মগুলি মেনে চলতে হয়:
              চাইল্ড ক্লাসে প্যারেন্ট ক্লাসের মেথডের সই স্ইগনেচার মেথড ডিক্লেয়ার করা হয়, এবং স্ইগনেচার মেথডের সুপার-ক্লাসে ডিক্লেয়ার করা মেথডের সাইনেচার অবশ্যই মেথডের নাম, প্যারামিটারের সংখ্যা, এবং প্যারামিটারের টাইপের সাথে মিল হতে হবে।
              চাইল্ড ক্লাসে মেথড ডিক্লেয়ার করার সময় @override অ্যানোটেশন ব্যবহার করতে হয়। এই অ্যানোটেশন ডার্ট কম্পাইলারের জন্য মেথড ওভাররাইড করছে এবং সেটি যদি সাইনেচার মেথডের সাথে মেলে তাদের একই হতে হবে।
              একটি উদাহরণ দেওয়া হলো:
              class Animal { 
                void makeSound() { 
                  print('Animals make sounds.'); 
                } 
              } 
              class Dog extends Animal { 
                @override // মেথড ওভাররাইড করার সঙ্গে সঙ্গে এটি এই ক্যাননিক্যাল মেথড আপনার কোড তালিকায় প্রদর্শন করে 
                void makeSound() { 
                  print('Dogs bark.'); 
                } 
              } 
              void main() {
                Animal animal = Dog(); // উত্তরাধিকারিত ক্লাসের অবজেক্ট 
                animal.makeSound(); // উত্তরাধিকারিত মেথড কল করা হলো 
              } 

              উপরে, "Animal" ক্লাসে "makeSound" মেথড ডিফাইন করা হয় যা বাড়িতে যে কোন প্রাণীর শব্দ বাহ্যিকরণ করে। "Dog" ক্লাস "Animal" ক্লাস থেকে উত্তরাধিকার নেয় এবং "makeSound" মেথড ওভাররাইড করে, সুপার-ক্লাসে ডিফাইন করা মেথডের নতুন বৈশিষ্ট্য যোগ করে। "main" ফাংশনে, আমরা "Dog" ক্লাসের অবজেক্ট তৈরি করে এবং তাকে "Animal" ক্লাসের রেফারেন্সে সংরক্ষণ করেছি। তারপর "makeSound" মেথড কল করা হয়, এবং আউটপুট দেখায় যে "Dog" ক্লাসের "makeSound" মেথড কল হয়েছে, তাহলে "Dogs bark." প্রিন্ট হয়।
              এটি উত্তরাধিকারিত ক্লাসে মেথড পুনর্নির্ধারণ করা দ্বারা মেথডের শক্তি এবং পুনর্নির্ধারণ করা সম্ভব করে, যাতে একই নামের মেথড সুপার-ক্লাসে আপনি কী করতে চান তা নির্ধারণ করতে সাহায্য করে।
              '''),
  DartBook(
      title: 'গেটার এবং সেটার (getters & setters)',
      description:
          '''গেটার মেথড একটি প্রোপার্টির মৌলিক মান প্রদান করে। যখন আপনি একটি গেটার মেথড ব্যবহার করেন, তখন আপনি সেই প্রোপার্টির মান পড়তে পাবেন, কিন্তু সেই মান পরিবর্তন করতে পারবেন না। গেটার মেথডের নাম সাধারণভাবে "get" দিয়ে শুরু হয় এবং প্রোপার্টির নাম সাথে যোগ হয়।
              গেটার মেথডের সৃষ্টি সূত্র:
              returnType get propertyName { // ভ্যারিয়েবল মান প্রাপ্ত করার লজিক } 

              class Person {
                String _name = '';

                String get name {
                  return _name;
                }
              }
              উপরের উদাহরণে, "name" গেটার মেথড প্রোপার্টি "_name" এর মৌলিক মান প্রদান করে।

              সেটার মেথড প্রোপার্টির মান পরিবর্তন করতে ব্যবহার করা হয়। যখন আপনি একটি সেটার মেথড ব্যবহার করেন, তখন আপনি প্রোপার্টির মান পরিবর্তন করতে পারেন। সেটার মেথডের নাম সাধারণভাবে "set" দিয়ে শুরু হয় এবং প্রোপার্টির নাম সাথে যোগ হয়।
              সেটার মেথডের সৃষ্টি সূত্র:
              set propertyName(newValue) { // ভ্যারিয়েবলে নতুন মান সেট করার লজিক } 

              class Person {
                String _name = '';

                String get name {
                  return _name;
                }

                void set name(String newName) {
                  _name = newName;
                }
              }
              উপরের উদাহরণে, "name" সেটার মেথড প্রোপার্টি "_name" এর মান পরিবর্তন করে।

              returnType: গেটার মেথডের ক্ষেত্রে, মাধ্যমে যেমন মৌলিক মান (int, double, String) প্রাপ্ত হয় তা নির্ধারণ করে। সেটার মেথডে, returnType হতে হবে 'void'.
              propertyName: গেটার এবং সেটার মেথডের নাম যা বৈশিষ্ট্যের মান প্রাপ্ত করতে এবং সেট করতে ব্যবহৃত হয়।
              newValue: সেটার মেথডে এই প্যারামিটারের মাধ্যমে নতুন মান পাঠানো হয়।
              একটি উদাহরণ দেওয়া হলো:
              class Circle { 
                double _radius = 0.0; // প্রাইভেট ভ্যারিয়েবল 
                _radius 

                // গেটার মেথড, বৈশিষ্ট্যের মান প্রাপ্ত করতে ব্যবহৃত 
                double get radius { 
                  return _radius; 
                } 
                
                // সেটার মেথড, বৈশিষ্ট্যের মান সেট করতে ব্যবহৃত 
                set radius(double newValue) { 
                  if (newValue >= 0) { 
                    _radius = newValue; 
                  }
                  else { 
                    print('Radius cannot be negative.'); 
                  } 
                } 
              } 

              void main() { 
                Circle circle = Circle(); // গেটার মেথডের ব্যবহার 
                print('Radius: ${circle.radius}'); // আউটপুট: 
                Radius: 0.0 // সেটার মেথডের ব্যবহার 
                circle.radius = 5.0; 
                print('Radius: ${circle.radius}'); // আউটপুট: 
                Radius: 5.0 // সেটার মেথডে অবৈধ মান পাঠানো 
                circle.radius = -2.0; // আউটপুট: Radius cannot be negative. 
              } 

              উপরে, "Circle" ক্লাসে একটি প্রাইভেট ভ্যারিয়েবল "_radius" আছে, যা গেটার এবং সেটার মেথডের মাধ্যমে এক্সেস করা হয়। "get radius" গেটার মেথডটি বৈশিষ্ট্যের মান প্রাপ্ত করে এবং "set radius" সেটার মেথডটি বৈশিষ্ট্যের মান সেট করে, তবে সেটার মেথডে একটি অবৈধ মান পাঠাতে প্রয়োজনে একটি সংরক্ষনা সূচনা প্রিন্ট করে।
              '''),
  DartBook(
      title: 'Exception',
      description:
          '''ডার্ট একটি প্রোগ্রামিং ভাষা যা একটি একটি সমস্যা বা ইউনিউজুয়াল ঘটনার সাথে সম্পর্কিত কোড লিখতে সাহায্য করে। ডার্টে যখন কোন সমস্যা ঘটে, তখন প্রোগ্রামটি স্বয়ংক্রিয়ভাবে একটি ইউনিউজুয়াল (exception) তৈরি করে এবং সমস্যা সম্পর্কিত সূচনা দেয়।
              ডার্টে ইউনিউজুয়াল গুলি সাধারণভাবে কিছু কারণে ঘটতে পারে, যেমন:
              ভ্যালিডেশন ইস্যু: ইনপুট ডেটা সঠিক না হলে ইউনিউজুয়াল ঘটতে পারে।
              ফাইল অপারেশনসমূহে ত্রুটি: ফাইলে লেখা বা পড়া যাওয়া সমস্যার সাথে ইউনিউজুয়াল তৈরি হতে পারে।
              নাল বা খালি ভেরিয়েবলে প্রবেশ: যখন আপনি নাল বা খালি মানগুলির সাথে কাজ করতে চান, তখন এই ধরনের ইউনিউজুয়াল প্রাপ্ত হতে পারে।
              একটি ইউনিউজুয়াল তৈরি হলে, ডার্ট একটি ইউনিউজুয়াল হ্যান্ডলার (exception handler) চালিয়ে সমস্যা সম্পর্কিত কোড একটি স্পেশাল ব্লকে চলে যায়, যা একটি try-catch ব্লক নামে পরিচিত।
              একটি সাধারণ ইউনিউজুয়াল হ্যান্ডলারের সাথে try এবং catch ব্লক ব্যবহার করে ডার্টে ইউনিউজুয়াল হ্যান্ডল করা হয়।
              একটি উদাহরণ দেখা যাক:
              void main() { 
                try { // এই কোডে একটি ইউনিউজুয়াল তৈরি হতে পারে 
                  var result = 10 ~/ 0; // ভাগ করা 0 সম্ভব নয় 
                  print(result); 
                } 
                catch (e) { // ইউনিউজুয়াল হ্যান্ডলার 
                  print('সমস্যা হয়েছে: $e'); // সমস্যার সাথে সম্পর্কিত সূচনা দেয় 
                } 
              } 

              উল্লিখিত উদাহরণে, ভাগ করা 0 সম্ভব না হওয়া কারণে একটি ইউনিউজুয়াল তৈরি হয়। catch ব্লকে সমস্যা সম্পর্কিত সূচনা দেওয়া হয়।
              এছাড়া, আপনি স্পেশালাইজড ইউনিউজুয়াল ক্যাচ ব্লক ব্যবহার করতে পারেন যেগুলি সমস্যার ধরনের ভিত্তিতে কাজ করে।
              একটি স্পেশালাইজড ইউনিউজুয়াল ক্যাচ ব্লকের সাথে একটি on কীওয়ার্ড ব্যবহার করে কোন নির্দিষ্ট ইউনিউজুয়াল তৈরি হলে এই ব্লক চলে যায়।
              এটির উদাহরণ:
              void main() { 
                try { 
                  var result = 10 ~/ 0; // ভাগ করা 0 সম্ভব নয় 
                  print(result); 
                } 
                on IntegerDivisionByZeroException { // এই ব্লক কেবল ভাগ করা 0 এর সাথে সম্পর্কিত ইউনিউজুয়াল হ্যান্ডল করে
                  print('ভাগ করা 0 সম্ভব নয়'); 
                } 
                catch (e) { // অন্য কোন সাধারণ ইউনিউজুয়াল হ্যান্ডলার 
                  print('সমস্যা হয়েছে: $e'); 
                } 
              } 

              উল্লিখিত উদাহরণে, on IntegerDivisionByZeroException ব্লক কেবল ভাগ করা 0 সাথে সম্পর্কিত ইউনিউজুয়াল হ্যান্ডল করে, আর অন্য সমস্যার সাথে সাধারণ ইউনিউজুয়াল হ্যান্ডল করে।

              এইভাবে, ডার্টে ইউনিউজুয়াল ব্যবস্থাপনা করতে সাহায্য করে এবং আপনার প্রোগ্রামগুলির নিরাপত্তা বাড়াতে সাহায্য করে।
'''),
];

mixin rectangle {
  static area() {}
}

mixin child {
  static var name;

  static var age;
}

mixin circle {
  static var radius;

  static area() {}
}

mixin c_i_r_c_l_e {}

mixin difference {}

mixin sum {}

mixin c_h_i_ld {
  static var age;
}

mixin c_h_i_l_d {
  static var name;
}

mixin t_h_i_s {
  static var name;

  static var age;
}

class Circle {
  static var pi;
}

mixin area {}

mixin person1 {
  static var name;

  static var age;
}

mixin school {}

mixin result {}

mixin count {}

mixin value {}

mixin key {}

mixin age {}

mixin i {}

mixin name {}
